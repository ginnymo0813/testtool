<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æµ‹è¯•å·¥å…·é›†</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 0;
            display: flex;
        }

        .sidebar {
            width: 280px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            box-shadow: 2px 0 20px rgba(0,0,0,0.1);
            padding: 20px;
            position: fixed;
            height: 100vh;
            overflow-y: auto;
            transition: transform 0.3s;
        }

        .sidebar h2 {
            color: #333;
            font-size: 1.8em;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 3px solid #667eea;
        }

        .nav-menu {
            list-style: none;
        }

        .nav-item {
            margin-bottom: 10px;
        }

        .nav-link {
            display: block;
            padding: 12px 15px;
            color: #555;
            text-decoration: none;
            border-radius: 8px;
            transition: all 0.3s;
            font-size: 16px;
        }

        .nav-link:hover {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            transform: translateX(5px);
        }

        .nav-link.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: 600;
        }

        .main-content {
            margin-left: 280px;
            flex: 1;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: white;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .menu-toggle {
            display: none;
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1001;
            background: white;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            font-size: 20px;
        }

        @media (max-width: 768px) {
            .sidebar {
                transform: translateX(-100%);
                z-index: 1000;
            }

            .sidebar.active {
                transform: translateX(0);
            }

            .main-content {
                margin-left: 0;
            }

            .menu-toggle {
                display: block;
            }
        }

        .tool-card {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 20px;
        }

        .tool-title {
            font-size: 1.5em;
            color: #333;
            margin-bottom: 20px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #555;
            font-weight: 600;
        }

        input[type="number"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
        }

        .checkbox-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            margin-right: 8px;
            cursor: pointer;
        }

        .checkbox-item label {
            margin: 0;
            cursor: pointer;
            font-weight: normal;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 14px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-right: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .result-area {
            margin-top: 20px;
        }

        .result-box {
            background: #f5f5f5;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            min-height: 100px;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            word-break: break-all;
            position: relative;
        }

        .copy-btn {
            background: #28a745;
            margin-top: 10px;
        }

        .copy-btn:hover {
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.4);
        }

        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 1000;
        }

        .toast.show {
            opacity: 1;
        }

        textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            resize: vertical;
            min-height: 120px;
            transition: border-color 0.3s;
        }

        textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-secondary:hover {
            box-shadow: 0 5px 15px rgba(108, 117, 125, 0.4);
        }

        .error-text {
            color: #dc3545;
            font-size: 14px;
            margin-top: 10px;
        }

        input[type="text"], input[type="datetime-local"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus, input[type="datetime-local"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .radio-group {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .radio-item {
            display: flex;
            align-items: center;
        }

        .radio-item input[type="radio"] {
            width: 18px;
            height: 18px;
            margin-right: 8px;
            cursor: pointer;
        }

        .radio-item label {
            margin: 0;
            cursor: pointer;
            font-weight: normal;
        }

        .stat-item {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            border: 2px solid #dee2e6;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .stat-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .stat-label {
            font-size: 14px;
            color: #6c757d;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .stat-value {
            font-size: 28px;
            color: #667eea;
            font-weight: 700;
            font-family: 'Courier New', monospace;
        }
    </style>
</head>
<body>
    <!-- ç§»åŠ¨ç«¯èœå•æŒ‰é’® -->
    <button class="menu-toggle" onclick="toggleMenu()">â˜°</button>

    <!-- å·¦ä¾§å¯¼èˆªæ  -->
    <div class="sidebar" id="sidebar">
        <h2>ğŸ”§ å·¥å…·å¯¼èˆª</h2>
        <ul class="nav-menu">
            <li class="nav-item">
                <a href="#random-string" class="nav-link active" onclick="scrollToTool('random-string', event)">
                    ğŸ² éšæœºå­—ç¬¦ä¸²ç”Ÿæˆå™¨
                </a>
            </li>
            <li class="nav-item">
                <a href="#json-formatter" class="nav-link" onclick="scrollToTool('json-formatter', event)">
                    ğŸ“ JSONæ ¼å¼åŒ–å·¥å…·
                </a>
            </li>
            <li class="nav-item">
                <a href="#base64" class="nav-link" onclick="scrollToTool('base64', event)">
                    ğŸ” Base64ç¼–è§£ç 
                </a>
            </li>
            <li class="nav-item">
                <a href="#timestamp" class="nav-link" onclick="scrollToTool('timestamp', event)">
                    â° æ—¶é—´æˆ³è½¬æ¢
                </a>
            </li>
            <li class="nav-item">
                <a href="#url-codec" class="nav-link" onclick="scrollToTool('url-codec', event)">
                    ğŸ”— URLç¼–è§£ç 
                </a>
            </li>
            <li class="nav-item">
                <a href="#hash" class="nav-link" onclick="scrollToTool('hash', event)">
                    ğŸ”’ å“ˆå¸ŒåŠ å¯†
                </a>
            </li>
            <li class="nav-item">
                <a href="#pairwise" class="nav-link" onclick="scrollToTool('pairwise', event)">
                    ğŸ”€ Pairwiseä¸¤ä¸¤ç»„åˆ
                </a>
            </li>
            <li class="nav-item">
                <a href="#time-diff" class="nav-link" onclick="scrollToTool('time-diff', event)">
                    â±ï¸ æ—¶é—´å·®è®¡ç®—å™¨
                </a>
            </li>
            <li class="nav-item">
                <a href="#file-generator" class="nav-link" onclick="scrollToTool('file-generator', event)">
                    ğŸ“„ æµ‹è¯•æ–‡ä»¶ç”Ÿæˆå™¨
                </a>
            </li>
            <li class="nav-item">
                <a href="#regex-tester" class="nav-link" onclick="scrollToTool('regex-tester', event)">
                    ğŸ” æ­£åˆ™è¡¨è¾¾å¼æµ‹è¯•
                </a>
            </li>
            <li class="nav-item">
                <a href="#char-counter" class="nav-link" onclick="scrollToTool('char-counter', event)">
                    ğŸ“Š å­—ç¬¦æ•°é‡ç»Ÿè®¡
                </a>
            </li>
        </ul>
    </div>

    <!-- ä¸»å†…å®¹åŒº -->
    <div class="main-content">
        <div class="container">
            <h1>ğŸ”§ æµ‹è¯•å·¥å…·é›†</h1>

            <!-- éšæœºå­—ç¬¦ç”Ÿæˆå™¨ -->
            <div class="tool-card" id="random-string">
                <h2 class="tool-title">ğŸ² éšæœºå­—ç¬¦ç”Ÿæˆå™¨</h2>
            
            <div class="form-group">
                <label for="length">å­—ç¬¦é•¿åº¦ï¼š</label>
                <input type="number" id="length" min="1" max="10000" value="16" placeholder="è¯·è¾“å…¥å­—ç¬¦é•¿åº¦">
            </div>

            <div class="form-group">
                <label>å­—ç¬¦ç±»å‹ï¼š</label>
                <div class="checkbox-group">
                    <div class="checkbox-item">
                        <input type="checkbox" id="uppercase" checked>
                        <label for="uppercase">å¤§å†™å­—æ¯ (A-Z)</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="lowercase" checked>
                        <label for="lowercase">å°å†™å­—æ¯ (a-z)</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="numbers" checked>
                        <label for="numbers">æ•°å­— (0-9)</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="symbols">
                        <label for="symbols">ç‰¹æ®Šå­—ç¬¦ (!@#$%^&*)</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="chinese">
                        <label for="chinese">ä¸­æ–‡å­—ç¬¦ (å¸¸ç”¨æ±‰å­—)</label>
                    </div>
                </div>
            </div>

            <div>
                <button class="btn" onclick="generateRandomString()">ç”Ÿæˆéšæœºå­—ç¬¦</button>
            </div>

            <div class="result-area">
                <label>ç”Ÿæˆç»“æœï¼š</label>
                <div class="result-box" id="result">ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®ç”Ÿæˆéšæœºå­—ç¬¦</div>
                <button class="btn copy-btn" onclick="copyResult('result')">ğŸ“‹ å¤åˆ¶åˆ°å‰ªè´´æ¿</button>
            </div>
        </div>

        <!-- JSONæ ¼å¼åŒ–å·¥å…· -->
        <div class="tool-card" id="json-formatter">
            <h2 class="tool-title">ğŸ“ JSONæ ¼å¼åŒ–</h2>
            
            <div class="form-group">
                <label for="jsonInput">è¾“å…¥JSONï¼š</label>
                <textarea id="jsonInput" placeholder="åœ¨æ­¤ç²˜è´´æˆ–è¾“å…¥JSONæ•°æ®..."></textarea>
            </div>

            <div class="btn-group">
                <button class="btn" onclick="formatJSON()">æ ¼å¼åŒ–</button>
                <button class="btn btn-secondary" onclick="compressJSON()">å‹ç¼©</button>
                <button class="btn btn-secondary" onclick="clearJSON()">æ¸…ç©º</button>
            </div>

            <div class="result-area">
                <label>æ ¼å¼åŒ–ç»“æœï¼š</label>
                <textarea id="jsonOutput" readonly placeholder="æ ¼å¼åŒ–åçš„JSONå°†æ˜¾ç¤ºåœ¨è¿™é‡Œ..."></textarea>
                <div id="jsonError" class="error-text"></div>
                <button class="btn copy-btn" onclick="copyTextarea('jsonOutput')">ğŸ“‹ å¤åˆ¶ç»“æœ</button>
            </div>
        </div>

        <!-- Base64ç¼–è§£ç  -->
        <div class="tool-card" id="base64">
            <h2 class="tool-title">ğŸ” Base64ç¼–è§£ç </h2>
            
            <div class="form-group">
                <label for="base64Input">è¾“å…¥æ–‡æœ¬ï¼š</label>
                <textarea id="base64Input" placeholder="åœ¨æ­¤è¾“å…¥è¦ç¼–ç æˆ–è§£ç çš„æ–‡æœ¬..."></textarea>
            </div>

            <div class="btn-group">
                <button class="btn" onclick="encodeBase64()">ç¼–ç </button>
                <button class="btn btn-secondary" onclick="decodeBase64()">è§£ç </button>
                <button class="btn btn-secondary" onclick="clearBase64()">æ¸…ç©º</button>
            </div>

            <div class="result-area">
                <label>ç»“æœï¼š</label>
                <textarea id="base64Output" readonly placeholder="ç¼–ç æˆ–è§£ç ç»“æœå°†æ˜¾ç¤ºåœ¨è¿™é‡Œ..."></textarea>
                <div id="base64Error" class="error-text"></div>
                <button class="btn copy-btn" onclick="copyTextarea('base64Output')">ğŸ“‹ å¤åˆ¶ç»“æœ</button>
            </div>
        </div>

        <!-- æ—¶é—´æˆ³è½¬æ¢ -->
        <div class="tool-card" id="timestamp">
            <h2 class="tool-title">â° æ—¶é—´æˆ³è½¬æ¢</h2>
            
            <div class="form-group">
                <label for="timestampInput">æ—¶é—´æˆ³ï¼ˆæ¯«ç§’ï¼‰ï¼š</label>
                <input type="text" id="timestampInput" placeholder="è¾“å…¥æ—¶é—´æˆ³ï¼Œç•™ç©ºåˆ™ä½¿ç”¨å½“å‰æ—¶é—´">
            </div>

            <div class="btn-group">
                <button class="btn" onclick="convertTimestamp()">è½¬æ¢ä¸ºæ—¥æœŸ</button>
                <button class="btn btn-secondary" onclick="getCurrentTimestamp()">è·å–å½“å‰æ—¶é—´æˆ³</button>
            </div>

            <div class="result-area">
                <label>è½¬æ¢ç»“æœï¼š</label>
                <div class="result-box" id="timestampResult">ç‚¹å‡»æŒ‰é’®è¿›è¡Œè½¬æ¢</div>
                <button class="btn copy-btn" onclick="copyResult('timestampResult')">ğŸ“‹ å¤åˆ¶ç»“æœ</button>
            </div>

            <hr style="margin: 30px 0; border: none; border-top: 1px solid #e0e0e0;">

            <div class="form-group">
                <label for="dateInput">æ—¥æœŸæ—¶é—´ï¼š</label>
                <input type="datetime-local" id="dateInput">
            </div>

            <div class="btn-group">
                <button class="btn" onclick="convertDateToTimestamp()">è½¬æ¢ä¸ºæ—¶é—´æˆ³</button>
            </div>

            <div class="result-area">
                <label>æ—¶é—´æˆ³ç»“æœï¼š</label>
                <div class="result-box" id="dateResult">é€‰æ‹©æ—¥æœŸåç‚¹å‡»è½¬æ¢</div>
                <button class="btn copy-btn" onclick="copyResult('dateResult')">ğŸ“‹ å¤åˆ¶æ—¶é—´æˆ³</button>
            </div>
        </div>

        <!-- URLç¼–è§£ç  -->
        <div class="tool-card" id="url-codec">
            <h2 class="tool-title">ğŸ”— URLç¼–è§£ç </h2>
            
            <div class="form-group">
                <label for="urlInput">è¾“å…¥URLæˆ–æ–‡æœ¬ï¼š</label>
                <textarea id="urlInput" placeholder="åœ¨æ­¤è¾“å…¥è¦ç¼–ç æˆ–è§£ç çš„URL..."></textarea>
            </div>

            <div class="btn-group">
                <button class="btn" onclick="encodeURL()">ç¼–ç </button>
                <button class="btn btn-secondary" onclick="decodeURL()">è§£ç </button>
                <button class="btn btn-secondary" onclick="clearURL()">æ¸…ç©º</button>
            </div>

            <div class="result-area">
                <label>ç»“æœï¼š</label>
                <textarea id="urlOutput" readonly placeholder="ç¼–ç æˆ–è§£ç ç»“æœå°†æ˜¾ç¤ºåœ¨è¿™é‡Œ..."></textarea>
                <div id="urlError" class="error-text"></div>
                <button class="btn copy-btn" onclick="copyTextarea('urlOutput')">ğŸ“‹ å¤åˆ¶ç»“æœ</button>
            </div>
        </div>

        <!-- MD5/SHAåŠ å¯† -->
        <div class="tool-card" id="hash">
            <h2 class="tool-title">ğŸ”’ å“ˆå¸ŒåŠ å¯† (MD5/SHA)</h2>
            
            <div class="form-group">
                <label for="hashInput">è¾“å…¥æ–‡æœ¬ï¼š</label>
                <textarea id="hashInput" placeholder="åœ¨æ­¤è¾“å…¥è¦åŠ å¯†çš„æ–‡æœ¬..."></textarea>
            </div>

            <div class="form-group">
                <label>åŠ å¯†ç®—æ³•ï¼š</label>
                <div class="radio-group">
                    <div class="radio-item">
                        <input type="radio" id="md5" name="hashAlgo" value="md5" checked>
                        <label for="md5">MD5</label>
                    </div>
                    <div class="radio-item">
                        <input type="radio" id="sha1" name="hashAlgo" value="sha1">
                        <label for="sha1">SHA-1</label>
                    </div>
                    <div class="radio-item">
                        <input type="radio" id="sha256" name="hashAlgo" value="sha256">
                        <label for="sha256">SHA-256</label>
                    </div>
                </div>
            </div>

            <div class="btn-group">
                <button class="btn" onclick="generateHash()">ç”Ÿæˆå“ˆå¸Œå€¼</button>
                <button class="btn btn-secondary" onclick="clearHash()">æ¸…ç©º</button>
            </div>

            <div class="result-area">
                <label>å“ˆå¸Œå€¼ï¼š</label>
                <div class="result-box" id="hashOutput">è¾“å…¥æ–‡æœ¬åç‚¹å‡»ç”Ÿæˆ</div>
                <button class="btn copy-btn" onclick="copyResult('hashOutput')">ğŸ“‹ å¤åˆ¶å“ˆå¸Œå€¼</button>
            </div>
        </div>

        <!-- æˆå¯¹ç»„åˆæµ‹è¯•å·¥å…· -->
        <div class="tool-card" id="pairwise">
            <h2 class="tool-title">ğŸ”€ æˆå¯¹ç»„åˆæµ‹è¯• (Pairwise Testing)</h2>
            
            <div class="form-group">
                <label>æµ‹è¯•å‚æ•°é…ç½®ï¼š</label>
                <p style="color: #666; font-size: 14px; margin-bottom: 10px;">
                    æ ¼å¼ï¼šå‚æ•°å: å€¼1, å€¼2, å€¼3ï¼ˆæ¯è¡Œä¸€ä¸ªå‚æ•°ï¼‰
                </p>
                <textarea id="pairwiseInput" placeholder="ç¤ºä¾‹ï¼š&#10;æµè§ˆå™¨: Chrome, Firefox, Safari, Edge&#10;æ“ä½œç³»ç»Ÿ: Windows, macOS, Linux&#10;åˆ†è¾¨ç‡: 1920x1080, 1366x768, 2560x1440&#10;è¯­è¨€: ä¸­æ–‡, è‹±æ–‡, æ—¥æ–‡" style="min-height: 150px;"></textarea>
            </div>

            <div class="form-group">
                <label for="pairwiseOrder">ç»„åˆå¼ºåº¦ï¼š</label>
                <div class="radio-group">
                    <div class="radio-item">
                        <input type="radio" id="pairwise2" name="pairwiseOrder" value="2" checked>
                        <label for="pairwise2">ä¸¤ä¸¤ç»„åˆ (Pairwise)</label>
                    </div>
                    <div class="radio-item">
                        <input type="radio" id="pairwise3" name="pairwiseOrder" value="3">
                        <label for="pairwise3">ä¸‰å› å­ç»„åˆ (3-way)</label>
                    </div>
                </div>
            </div>

            <div class="btn-group">
                <button class="btn" onclick="generatePairwise()">ç”Ÿæˆæµ‹è¯•ç”¨ä¾‹</button>
                <button class="btn btn-secondary" onclick="loadPairwiseExample()">åŠ è½½ç¤ºä¾‹</button>
                <button class="btn btn-secondary" onclick="clearPairwise()">æ¸…ç©º</button>
            </div>

            <div class="result-area">
                <label>ç”Ÿæˆçš„æµ‹è¯•ç”¨ä¾‹ï¼š</label>
                <div id="pairwiseStats" style="background: #f0f8ff; padding: 10px; border-radius: 5px; margin-bottom: 10px; display: none;">
                    <strong>ç»Ÿè®¡ä¿¡æ¯ï¼š</strong>
                    <span id="pairwiseStatsText"></span>
                </div>
                <textarea id="pairwiseOutput" readonly placeholder="ç‚¹å‡»ç”ŸæˆæŒ‰é’®åï¼Œæµ‹è¯•ç”¨ä¾‹å°†æ˜¾ç¤ºåœ¨è¿™é‡Œ..." style="min-height: 200px;"></textarea>
                <div id="pairwiseError" class="error-text"></div>
                <button class="btn copy-btn" onclick="copyTextarea('pairwiseOutput')">ğŸ“‹ å¤åˆ¶ç”¨ä¾‹</button>
                <button class="btn copy-btn" style="background: #17a2b8; margin-left: 10px;" onclick="exportPairwiseCSV()">ğŸ“¥ å¯¼å‡ºCSV</button>
            </div>
        </div>

        <!-- æ—¶é—´å·®è®¡ç®—å·¥å…· -->
        <div class="tool-card" id="time-diff">
            <h2 class="tool-title">â±ï¸ æ—¶é—´å·®è®¡ç®—</h2>
            
            <div class="form-group">
                <label for="startTime">å¼€å§‹æ—¶é—´ï¼š</label>
                <input type="text" id="startTime" placeholder="æ ¼å¼ï¼šYYYY-MM-DD HH:mm:ss æˆ– YYYY-MM-DD" value="">
                <button class="btn" style="margin-top: 10px; padding: 8px 15px; font-size: 14px;" onclick="setCurrentTime('startTime')">ä½¿ç”¨å½“å‰æ—¶é—´</button>
            </div>

            <div class="form-group">
                <label for="endTime">ç»“æŸæ—¶é—´ï¼š</label>
                <input type="text" id="endTime" placeholder="æ ¼å¼ï¼šYYYY-MM-DD HH:mm:ss æˆ– YYYY-MM-DD" value="">
                <button class="btn" style="margin-top: 10px; padding: 8px 15px; font-size: 14px;" onclick="setCurrentTime('endTime')">ä½¿ç”¨å½“å‰æ—¶é—´</button>
            </div>

            <div class="btn-group">
                <button class="btn" onclick="calculateTimeDifference()">è®¡ç®—æ—¶é—´å·®</button>
                <button class="btn btn-secondary" onclick="loadTimeDiffExample()">åŠ è½½ç¤ºä¾‹</button>
                <button class="btn btn-secondary" onclick="clearTimeDiff()">æ¸…ç©º</button>
            </div>

            <div class="result-area">
                <label>è®¡ç®—ç»“æœï¼š</label>
                <div class="result-box" id="timeDiffResult" style="min-height: 150px;">
                    è¾“å…¥ä¸¤ä¸ªæ—¶é—´åç‚¹å‡»è®¡ç®—
                </div>
                <div id="timeDiffError" class="error-text"></div>
                <button class="btn copy-btn" onclick="copyResult('timeDiffResult')">ğŸ“‹ å¤åˆ¶ç»“æœ</button>
            </div>

            <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; font-size: 14px; color: #666;">
                <strong>ğŸ’¡ æ”¯æŒçš„æ—¶é—´æ ¼å¼ï¼š</strong>
                <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                    <li>YYYY-MM-DD HH:mm:ss ï¼ˆå¦‚ï¼š2024-10-16 14:37:49ï¼‰</li>
                    <li>YYYY-MM-DD ï¼ˆå¦‚ï¼š2024-10-16ï¼‰</li>
                    <li>YYYY/MM/DD HH:mm:ss</li>
                    <li>YYYY/MM/DD</li>
                </ul>
            </div>
        </div>

        <!-- æµ‹è¯•æ–‡ä»¶ç”Ÿæˆå™¨ -->
        <div class="tool-card" id="file-generator">
            <h2 class="tool-title">ğŸ“„ æµ‹è¯•æ–‡ä»¶ç”Ÿæˆå™¨</h2>
            
            <div class="form-group">
                <label for="fileFormat">æ–‡ä»¶æ ¼å¼ï¼š</label>
                <select id="fileFormat" onchange="updateFileFormatUI()" style="width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 16px;">
                    <optgroup label="ğŸ“ æ–‡æœ¬æ–‡ä»¶">
                        <option value="txt">TXT - çº¯æ–‡æœ¬æ–‡ä»¶</option>
                        <option value="csv">CSV - é€—å·åˆ†éš”å€¼æ–‡ä»¶</option>
                        <option value="json">JSON - æ•°æ®äº¤æ¢æ ¼å¼</option>
                        <option value="xml">XML - æ ‡è®°è¯­è¨€æ–‡ä»¶</option>
                        <option value="html">HTML - ç½‘é¡µæ–‡ä»¶</option>
                        <option value="log">LOG - æ—¥å¿—æ–‡ä»¶</option>
                    </optgroup>
                    <optgroup label="ğŸ“Š æ•°æ®æ–‡ä»¶">
                        <option value="sql">SQL - æ•°æ®åº“è„šæœ¬</option>
                        <option value="md">MD - Markdownæ–‡æ¡£</option>
                    </optgroup>
                    <optgroup label="ğŸ–¼ï¸ å›¾ç‰‡æ–‡ä»¶">
                        <option value="png">PNG - PNGå›¾ç‰‡</option>
                        <option value="jpg">JPG - JPEGå›¾ç‰‡</option>
                        <option value="gif">GIF - GIFåŠ¨å›¾</option>
                        <option value="bmp">BMP - ä½å›¾å›¾ç‰‡</option>
                        <option value="svg">SVG - çŸ¢é‡å›¾å½¢</option>
                    </optgroup>
                    <optgroup label="ğŸ“„ æ–‡æ¡£æ–‡ä»¶">
                        <option value="pdf">PDF - PDFæ–‡æ¡£</option>
                        <option value="docx">DOCX - Wordæ–‡æ¡£</option>
                        <option value="xlsx">XLSX - Excelè¡¨æ ¼</option>
                        <option value="pptx">PPTX - PowerPointæ¼”ç¤ºæ–‡ç¨¿</option>
                    </optgroup>
                    <optgroup label="ğŸ“¦ å‹ç¼©æ–‡ä»¶">
                        <option value="zip">ZIP - å‹ç¼©åŒ…</option>
                    </optgroup>
                    <optgroup label="ğŸ’¾ äºŒè¿›åˆ¶æ–‡ä»¶">
                        <option value="bin">BIN - äºŒè¿›åˆ¶æ–‡ä»¶</option>
                        <option value="dat">DAT - æ•°æ®æ–‡ä»¶</option>
                    </optgroup>
                    <optgroup label="ğŸ”§ å…¶ä»–">
                        <option value="custom">è‡ªå®šä¹‰æ‰©å±•å</option>
                    </optgroup>
                </select>
            </div>

            <div class="form-group" id="customExtGroup" style="display: none;">
                <label for="customExt">è‡ªå®šä¹‰æ‰©å±•åï¼š</label>
                <input type="text" id="customExt" placeholder="ä¾‹å¦‚: pdf, docx, xlsx" maxlength="10">
            </div>

            <div class="form-group">
                <label>å¿«é€Ÿé€‰æ‹©æ–‡ä»¶å¤§å°ï¼š</label>
                <div class="btn-group" style="margin-bottom: 15px;">
                    <button class="btn btn-secondary" style="padding: 8px 15px; font-size: 14px;" onclick="setQuickSize(10, 'KB')">10 KB</button>
                    <button class="btn btn-secondary" style="padding: 8px 15px; font-size: 14px;" onclick="setQuickSize(100, 'KB')">100 KB</button>
                    <button class="btn btn-secondary" style="padding: 8px 15px; font-size: 14px;" onclick="setQuickSize(1, 'MB')">1 MB</button>
                    <button class="btn btn-secondary" style="padding: 8px 15px; font-size: 14px;" onclick="setQuickSize(10, 'MB')">10 MB</button>
                    <button class="btn btn-secondary" style="padding: 8px 15px; font-size: 14px;" onclick="setQuickSize(100, 'MB')">100 MB</button>
                    <button class="btn btn-secondary" style="padding: 8px 15px; font-size: 14px;" onclick="setQuickSize(500, 'MB')">500 MB</button>
                    <button class="btn btn-secondary" style="padding: 8px 15px; font-size: 14px;" onclick="setQuickSize(1, 'GB')">1 GB</button>
                </div>
            </div>

            <div class="form-group">
                <label for="fileSize">è‡ªå®šä¹‰æ–‡ä»¶å¤§å°ï¼š</label>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="number" id="fileSize" min="0.001" max="10240" step="0.001" value="1" placeholder="æ–‡ä»¶å¤§å°" style="flex: 1;">
                    <select id="sizeUnit" style="width: 120px; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 16px;">
                        <option value="KB">KB</option>
                        <option value="MB" selected>MB</option>
                        <option value="GB">GB</option>
                    </select>
                </div>
            </div>

            <div class="form-group">
                <label for="fileName">æ–‡ä»¶åï¼š</label>
                <input type="text" id="fileName" value="test_file" placeholder="è¯·è¾“å…¥æ–‡ä»¶åï¼ˆä¸å«æ‰©å±•åï¼‰">
            </div>

            <div class="form-group" id="contentTypeGroup">
                <label>æ–‡ä»¶å†…å®¹ï¼š</label>
                <div style="display: flex; flex-direction: column; gap: 10px;">
                    <div class="radio-item">
                        <input type="radio" id="contentRandom" name="contentType" value="random" checked>
                        <label for="contentRandom">éšæœºå­—ç¬¦ - é€‚åˆæµ‹è¯•æ–‡æœ¬å¤„ç†</label>
                    </div>
                    <div class="radio-item">
                        <input type="radio" id="contentRepeated" name="contentType" value="repeated">
                        <label for="contentRepeated">é‡å¤æ–‡æœ¬ - é«˜å‹ç¼©æ¯”ï¼Œé€‚åˆæµ‹è¯•å‹ç¼©</label>
                    </div>
                    <div class="radio-item">
                        <input type="radio" id="contentNumbers" name="contentType" value="numbers">
                        <label for="contentNumbers">æ•°å­—åºåˆ— - é€‚åˆæµ‹è¯•æ•°æ®å¯¼å…¥</label>
                    </div>
                    <div class="radio-item">
                        <input type="radio" id="contentStructured" name="contentType" value="structured">
                        <label for="contentStructured">ç»“æ„åŒ–æ•°æ® - æ ¹æ®æ–‡ä»¶æ ¼å¼ç”ŸæˆçœŸå®ç»“æ„</label>
                    </div>
                    <div class="radio-item">
                        <input type="radio" id="contentZeros" name="contentType" value="zeros">
                        <label for="contentZeros">å…¨é›¶æ•°æ® - æœ€é«˜å‹ç¼©æ¯”</label>
                    </div>
                </div>
            </div>

            <div class="btn-group">
                <button class="btn" onclick="generateAndDownloadFile()">ğŸš€ ç”Ÿæˆå¹¶ä¸‹è½½æ–‡ä»¶</button>
                <button class="btn btn-secondary" onclick="generateBatch()">ğŸ“¦ æ‰¹é‡ç”Ÿæˆ</button>
                <button class="btn btn-secondary" onclick="loadFileGenExample()">ğŸ’¡ åŠ è½½ç¤ºä¾‹</button>
            </div>

            <!-- æ‰¹é‡ç”Ÿæˆé…ç½® -->
            <div id="batchConfigGroup" style="display: none; margin-top: 20px; padding: 20px; background: #f8f9fa; border-radius: 8px; border: 2px dashed #667eea;">
                <h3 style="margin-bottom: 15px; color: #667eea;">ğŸ“¦ æ‰¹é‡ç”Ÿæˆé…ç½®</h3>
                <div class="form-group">
                    <label>é€‰æ‹©è¦ç”Ÿæˆçš„æ–‡ä»¶ï¼š</label>
                    <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 10px;">
                        <div class="checkbox-item">
                            <input type="checkbox" id="batch10KB" checked>
                            <label for="batch10KB">10 KB</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="batch100KB" checked>
                            <label for="batch100KB">100 KB</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="batch1MB" checked>
                            <label for="batch1MB">1 MB</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="batch10MB" checked>
                            <label for="batch10MB">10 MB</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="batch100MB">
                            <label for="batch100MB">100 MB</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="batch500MB">
                            <label for="batch500MB">500 MB</label>
                        </div>
                    </div>
                </div>
                <div class="btn-group">
                    <button class="btn" onclick="executeBatchGeneration()">å¼€å§‹æ‰¹é‡ç”Ÿæˆ</button>
                    <button class="btn btn-secondary" onclick="cancelBatch()">å–æ¶ˆ</button>
                </div>
            </div>

            <!-- æ·»åŠ è¿›åº¦æ¡ -->
            <div id="progressContainer" style="display: none; margin-top: 20px;">
                <div style="background: #e0e0e0; border-radius: 10px; height: 30px; overflow: hidden;">
                    <div id="progressBar" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); height: 100%; width: 0%; transition: width 0.3s; display: flex; align-items: center; justify-content: center; color: white; font-weight: 600; font-size: 14px;">
                        0%
                    </div>
                </div>
                <div id="progressText" style="margin-top: 10px; color: #666; font-size: 14px; text-align: center;">
                    å‡†å¤‡ç”Ÿæˆ...
                </div>
            </div>

            <div class="result-area">
                <label>æ–‡ä»¶ä¿¡æ¯ï¼š</label>
                <div class="result-box" id="fileGenResult" style="min-height: 120px;">
                    ç‚¹å‡»ç”ŸæˆæŒ‰é’®åˆ›å»ºæµ‹è¯•æ–‡ä»¶
                </div>
                <div id="fileGenError" class="error-text"></div>
            </div>

            <div style="margin-top: 20px; padding: 15px; background: #e8f5e9; border-radius: 8px; font-size: 14px; color: #2e7d32;">
                <strong>âœ¨ æ”¯æŒçš„æ–‡ä»¶æ ¼å¼ï¼š</strong>
                <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                    <li><strong>æ–‡æœ¬ç±»</strong>ï¼šTXT, CSV, JSON, XML, HTML, LOG, MD, SQL</li>
                    <li><strong>å›¾ç‰‡ç±»</strong>ï¼šPNG, JPG, GIF, BMP, SVGï¼ˆå¸¦å®Œæ•´æ–‡ä»¶å¤´ï¼Œå¯é¢„è§ˆï¼‰</li>
                    <li><strong>æ–‡æ¡£ç±»</strong>ï¼šPDF, DOCX, XLSX, PPTXï¼ˆå¯æ­£å¸¸æ‰“å¼€ï¼‰</li>
                    <li><strong>å‹ç¼©åŒ…</strong>ï¼šZIPï¼ˆå¯æ­£å¸¸è§£å‹ï¼‰</li>
                    <li><strong>äºŒè¿›åˆ¶</strong>ï¼šBIN, DAT åŠè‡ªå®šä¹‰æ ¼å¼</li>
                    <li><strong>ç»“æ„åŒ–æ•°æ®</strong>ï¼šè‡ªåŠ¨ç”Ÿæˆç¬¦åˆæ ¼å¼è§„èŒƒçš„çœŸå®æ•°æ®</li>
                </ul>
            </div>

            <div style="margin-top: 15px; padding: 15px; background: #fff3cd; border-radius: 8px; font-size: 14px; color: #856404;">
                <strong>âš ï¸ ä½¿ç”¨å»ºè®®ï¼š</strong>
                <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                    <li>50MBä»¥ä¸Šæ–‡ä»¶å°†æ˜¾ç¤ºç”Ÿæˆè¿›åº¦</li>
                    <li><strong>æ¨èå•æ¬¡ç”Ÿæˆä¸è¶…è¿‡2GB</strong></li>
                    <li>æ‰¹é‡ç”Ÿæˆå¯ä¸€æ¬¡åˆ›å»ºå¤šä¸ªä¸åŒå¤§å°çš„æµ‹è¯•æ–‡ä»¶</li>
                    <li>ç»“æ„åŒ–æ•°æ®æ¨¡å¼ä¼šç”ŸæˆçœŸå®æ ¼å¼çš„æ–‡ä»¶å†…å®¹ï¼ˆPDFã€å›¾ç‰‡ç­‰è‡ªåŠ¨ä½¿ç”¨ï¼‰</li>
                    <li>å…¨é›¶æ•°æ®é€‚åˆæµ‹è¯•å‹ç¼©ç®—æ³•æ•ˆç‡</li>
                    <li>PDFã€DOCXç­‰æ–‡æ¡£æ ¼å¼ä¼šç”ŸæˆçœŸå®å¯æ‰“å¼€çš„æ–‡ä»¶</li>
                </ul>
            </div>
        </div>

        <!-- æ­£åˆ™è¡¨è¾¾å¼æµ‹è¯•å™¨ -->
        <div class="tool-card" id="regex-tester">
            <h2 class="tool-title">ğŸ” æ­£åˆ™è¡¨è¾¾å¼æµ‹è¯•å™¨</h2>
            
            <div class="form-group">
                <label for="regexPattern">æ­£åˆ™è¡¨è¾¾å¼ï¼š</label>
                <input type="text" id="regexPattern" placeholder="ä¾‹å¦‚: \d{3}-\d{4}-\d{4}" value="">
            </div>

            <div class="form-group">
                <label>åŒ¹é…é€‰é¡¹ï¼š</label>
                <div class="checkbox-group">
                    <div class="checkbox-item">
                        <input type="checkbox" id="regexGlobal" checked>
                        <label for="regexGlobal">å…¨å±€åŒ¹é… (g)</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="regexMultiline">
                        <label for="regexMultiline">å¤šè¡Œæ¨¡å¼ (m)</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="regexIgnoreCase">
                        <label for="regexIgnoreCase">å¿½ç•¥å¤§å°å†™ (i)</label>
                    </div>
                </div>
            </div>

            <div class="form-group">
                <label for="regexTestText">æµ‹è¯•æ–‡æœ¬ï¼š</label>
                <textarea id="regexTestText" rows="6" placeholder="è¯·è¾“å…¥è¦æµ‹è¯•çš„æ–‡æœ¬å†…å®¹&#10;æ”¯æŒå¤šè¡Œæ–‡æœ¬"></textarea>
            </div>

            <div class="btn-group">
                <button class="btn" onclick="testRegex()">æµ‹è¯•åŒ¹é…</button>
                <button class="btn btn-secondary" onclick="replaceWithRegex()">æ›¿æ¢</button>
                <button class="btn btn-secondary" onclick="extractWithRegex()">æå–åŒ¹é…é¡¹</button>
                <button class="btn btn-secondary" onclick="loadRegexExample()">åŠ è½½ç¤ºä¾‹</button>
                <button class="btn btn-secondary" onclick="clearRegex()">æ¸…ç©º</button>
            </div>

            <div class="form-group" id="regexReplaceGroup" style="display: none;">
                <label for="regexReplaceText">æ›¿æ¢ä¸ºï¼š</label>
                <input type="text" id="regexReplaceText" placeholder="æ›¿æ¢å†…å®¹ï¼Œå¯ä½¿ç”¨ $1, $2... å¼•ç”¨æ•è·ç»„">
            </div>

            <div class="result-area">
                <label>åŒ¹é…ç»“æœï¼š</label>
                <div class="result-box" id="regexResult" style="min-height: 100px; white-space: pre-wrap;">
                    è¾“å…¥æ­£åˆ™è¡¨è¾¾å¼å’Œæµ‹è¯•æ–‡æœ¬åç‚¹å‡»æµ‹è¯•
                </div>
                <div id="regexError" class="error-text"></div>
            </div>

            <div style="margin-top: 20px; padding: 15px; background: #e3f2fd; border-radius: 8px; font-size: 14px; color: #1565c0;">
                <strong>ğŸ’¡ ä½¿ç”¨æç¤ºï¼š</strong>
                <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                    <li><code>\d</code> åŒ¹é…æ•°å­—ï¼Œ<code>\w</code> åŒ¹é…å­—æ¯æ•°å­—ä¸‹åˆ’çº¿ï¼Œ<code>\s</code> åŒ¹é…ç©ºç™½å­—ç¬¦</li>
                    <li><code>+</code> ä¸€æ¬¡æˆ–å¤šæ¬¡ï¼Œ<code>*</code> é›¶æ¬¡æˆ–å¤šæ¬¡ï¼Œ<code>?</code> é›¶æ¬¡æˆ–ä¸€æ¬¡</li>
                    <li><code>()</code> æ•è·ç»„ï¼Œå¯åœ¨æ›¿æ¢ä¸­ç”¨ <code>$1</code>, <code>$2</code>... å¼•ç”¨</li>
                    <li><code>[abc]</code> åŒ¹é… a æˆ– b æˆ– cï¼Œ<code>[^abc]</code> åŒ¹é…é™¤ aã€bã€c å¤–çš„å­—ç¬¦</li>
                    <li>ç¤ºä¾‹ï¼š<code>^1[3-9]\d{9}$</code> åŒ¹é…æ‰‹æœºå·ï¼Œ<code>\b\w+@\w+\.\w+\b</code> åŒ¹é…é‚®ç®±</li>
                </ul>
            </div>
        </div>

        <!-- å­—ç¬¦æ•°é‡ç»Ÿè®¡ -->
        <div class="tool-card" id="char-counter">
            <h2 class="tool-title">ğŸ“Š å­—ç¬¦æ•°é‡ç»Ÿè®¡</h2>
            
            <div class="form-group">
                <label for="charCountText">è¾“å…¥æ–‡æœ¬ï¼š</label>
                <textarea id="charCountText" rows="10" placeholder="è¯·è¾“å…¥æˆ–ç²˜è´´è¦ç»Ÿè®¡çš„æ–‡æœ¬å†…å®¹" oninput="countCharacters()"></textarea>
            </div>

            <div class="btn-group">
                <button class="btn btn-secondary" onclick="loadCharCountExample()">åŠ è½½ç¤ºä¾‹</button>
                <button class="btn btn-secondary" onclick="clearCharCount()">æ¸…ç©º</button>
            </div>

            <div class="result-area">
                <label>ç»Ÿè®¡ç»“æœï¼š</label>
                <div class="result-box" id="charCountResult" style="min-height: 300px;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                        <div class="stat-item">
                            <div class="stat-label">å­—ç¬¦æ€»æ•°</div>
                            <div class="stat-value" id="totalChars">0</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">å­—ç¬¦æ•°ï¼ˆä¸å«ç©ºæ ¼ï¼‰</div>
                            <div class="stat-value" id="charsNoSpace">0</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">ä¸­æ–‡å­—ç¬¦æ•°</div>
                            <div class="stat-value" id="chineseChars">0</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">è‹±æ–‡å­—æ¯æ•°</div>
                            <div class="stat-value" id="englishChars">0</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">æ•°å­—å­—ç¬¦æ•°</div>
                            <div class="stat-value" id="digitChars">0</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">æ ‡ç‚¹ç¬¦å·æ•°</div>
                            <div class="stat-value" id="punctuationChars">0</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">ç©ºæ ¼æ•°</div>
                            <div class="stat-value" id="spaceChars">0</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">è¡Œæ•°</div>
                            <div class="stat-value" id="lineCount">0</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">å•è¯æ•°</div>
                            <div class="stat-value" id="wordCount">0</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">æ®µè½æ•°</div>
                            <div class="stat-value" id="paragraphCount">0</div>
                        </div>
                    </div>
                </div>
            </div>

            <div style="margin-top: 20px; padding: 15px; background: #f3e5f5; border-radius: 8px; font-size: 14px; color: #6a1b9a;">
                <strong>ğŸ“ è¯´æ˜ï¼š</strong>
                <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                    <li><strong>å­—ç¬¦æ€»æ•°</strong>ï¼šåŒ…å«æ‰€æœ‰å­—ç¬¦ï¼ˆå«ç©ºæ ¼ã€æ¢è¡Œç­‰ï¼‰</li>
                    <li><strong>å­—ç¬¦æ•°ï¼ˆä¸å«ç©ºæ ¼ï¼‰</strong>ï¼šä¸åŒ…å«ç©ºæ ¼ã€åˆ¶è¡¨ç¬¦ã€æ¢è¡Œç¬¦çš„å­—ç¬¦æ•°</li>
                    <li><strong>ä¸­æ–‡å­—ç¬¦</strong>ï¼šåŒ…å«æ±‰å­—ã€ä¸­æ–‡æ ‡ç‚¹ç¬¦å·</li>
                    <li><strong>å•è¯æ•°</strong>ï¼šä»¥ç©ºæ ¼åˆ†éš”çš„å•è¯æ•°é‡ï¼ˆé€‚ç”¨äºè‹±æ–‡ï¼‰</li>
                    <li><strong>æ®µè½æ•°</strong>ï¼šä»¥ç©ºè¡Œåˆ†éš”çš„æ®µè½æ•°é‡</li>
                    <li>ç»Ÿè®¡å®æ—¶æ›´æ–°ï¼Œæ— éœ€ç‚¹å‡»æŒ‰é’®</li>
                </ul>
            </div>
        </div>
    </div>
    </div>

    <div class="toast" id="toast">å¤åˆ¶æˆåŠŸï¼</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script>
        // ========== å¯¼èˆªèœå•åŠŸèƒ½ ==========
        // å¹³æ»‘æ»šåŠ¨åˆ°å¯¹åº”å·¥å…·
        function scrollToTool(toolId, event) {
            const element = document.getElementById(toolId);
            if (element) {
                element.scrollIntoView({ behavior: 'smooth', block: 'start' });
                
                // æ›´æ–°å¯¼èˆªæ¿€æ´»çŠ¶æ€
                document.querySelectorAll('.nav-link').forEach(link => {
                    link.classList.remove('active');
                });
                if (event && event.target) {
                    event.target.classList.add('active');
                }
                
                // ç§»åŠ¨ç«¯è‡ªåŠ¨å…³é—­èœå•
                if (window.innerWidth <= 768) {
                    document.getElementById('sidebar').classList.remove('active');
                }
            }
            return false;
        }

        // åˆ‡æ¢ç§»åŠ¨ç«¯èœå•
        function toggleMenu() {
            document.getElementById('sidebar').classList.toggle('active');
        }

        // ç›‘å¬æ»šåŠ¨ï¼Œè‡ªåŠ¨æ›´æ–°å¯¼èˆªé«˜äº®
        window.addEventListener('scroll', () => {
            const sections = ['random-string', 'json-formatter', 'base64', 'timestamp', 'url-codec', 'hash', 'pairwise', 'time-diff', 'file-generator'];
            const scrollPos = window.scrollY + 100;

            sections.forEach(sectionId => {
                const section = document.getElementById(sectionId);
                if (section) {
                    const sectionTop = section.offsetTop;
                    const sectionBottom = sectionTop + section.offsetHeight;

                    if (scrollPos >= sectionTop && scrollPos < sectionBottom) {
                        document.querySelectorAll('.nav-link').forEach(link => {
                            link.classList.remove('active');
                        });
                        document.querySelector(`a[href="#${sectionId}"]`).classList.add('active');
                    }
                }
            });
        });

        // ========== é€šç”¨å‡½æ•° ==========
        // æ˜¾ç¤ºæç¤ºæ¶ˆæ¯
        function showToast(message = 'å¤åˆ¶æˆåŠŸï¼') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 2000);
        }

        // å¤åˆ¶ç»“æœæ¡†å†…å®¹
        function copyResult(elementId) {
            const resultText = document.getElementById(elementId).textContent;
            
            if (!resultText || resultText.includes('ç‚¹å‡»') || resultText.includes('é€‰æ‹©')) {
                alert('æ²¡æœ‰å¯å¤åˆ¶çš„å†…å®¹');
                return;
            }

            copyToClipboard(resultText);
        }

        // å¤åˆ¶æ–‡æœ¬åŸŸå†…å®¹
        function copyTextarea(elementId) {
            const textarea = document.getElementById(elementId);
            const text = textarea.value;
            
            if (!text) {
                alert('æ²¡æœ‰å¯å¤åˆ¶çš„å†…å®¹');
                return;
            }

            copyToClipboard(text);
        }

        // é€šç”¨å¤åˆ¶å‡½æ•°
        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                showToast();
            }).catch(() => {
                // é™çº§æ–¹æ¡ˆ
                const textarea = document.createElement('textarea');
                textarea.value = text;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                showToast();
            });
        }

        // ========== éšæœºå­—ç¬¦ç”Ÿæˆå™¨ ==========
        // å¸¸ç”¨æ±‰å­—å­—ç¬¦é›†ï¼ˆ3500ä¸ªå¸¸ç”¨æ±‰å­—ï¼‰
        const commonChinese = 'çš„ä¸€æ˜¯åœ¨ä¸äº†æœ‰å’Œäººè¿™ä¸­å¤§ä¸ºä¸Šä¸ªå›½æˆ‘ä»¥è¦ä»–æ—¶æ¥ç”¨ä»¬ç”Ÿåˆ°ä½œåœ°äºå‡ºå°±åˆ†å¯¹æˆä¼šå¯ä¸»å‘å¹´åŠ¨åŒå·¥ä¹Ÿèƒ½ä¸‹è¿‡å­è¯´äº§ç§é¢è€Œæ–¹åå¤šå®šè¡Œå­¦æ³•æ‰€æ°‘å¾—ç»åä¸‰ä¹‹è¿›ç€ç­‰éƒ¨åº¦å®¶ç”µåŠ›é‡Œå¦‚æ°´åŒ–é«˜è‡ªäºŒç†èµ·å°ç‰©ç°å®åŠ é‡éƒ½ä¸¤ä½“åˆ¶æœºå½“ä½¿ç‚¹ä»ä¸šæœ¬å»æŠŠæ€§å¥½åº”å¼€å®ƒåˆè¿˜å› ç”±å…¶äº›ç„¶å‰å¤–å¤©æ”¿å››æ—¥é‚£ç¤¾ä¹‰äº‹å¹³å½¢ç›¸å…¨è¡¨é—´æ ·ä¸å…³å„é‡æ–°çº¿å†…æ•°æ­£å¿ƒåä½ æ˜çœ‹åŸåˆä¹ˆåˆ©æ¯”æˆ–ä½†è´¨æ°”ç¬¬å‘é“å‘½æ­¤å˜æ¡åªæ²¡ç»“è§£é—®æ„å»ºæœˆå…¬æ— ç³»å†›å¾ˆæƒ…è€…æœ€ç«‹ä»£æƒ³å·²é€šå¹¶æç›´é¢˜å…šç¨‹å±•äº”æœæ–™è±¡å‘˜é©ä½å…¥å¸¸æ–‡æ€»æ¬¡å“å¼æ´»è®¾åŠç®¡ç‰¹ä»¶é•¿æ±‚è€å¤´åŸºèµ„è¾¹æµè·¯çº§å°‘å›¾å±±ç»Ÿæ¥çŸ¥è¾ƒå°†ç»„è§è®¡åˆ«å¥¹æ‰‹è§’æœŸæ ¹è®ºè¿å†œæŒ‡å‡ ä¹åŒºå¼ºæ”¾å†³è¥¿è¢«å¹²åšå¿…æˆ˜å…ˆå›åˆ™ä»»å–æ®å¤„é˜Ÿå—ç»™è‰²å…‰é—¨å³ä¿æ²»åŒ—é€ ç™¾è§„çƒ­é¢†ä¸ƒæµ·å£ä¸œå¯¼å™¨å‹å¿—ä¸–é‡‘å¢äº‰æµé˜¶æ²¹æ€æœ¯æäº¤å—è”ä»€è®¤å…­å…±æƒæ”¶è¯æ”¹æ¸…å·±ç¾å†é‡‡è½¬æ›´å•é£åˆ‡æ‰“ç™½æ•™é€ŸèŠ±å¸¦å®‰åœºèº«è½¦ä¾‹çœŸåŠ¡å…·ä¸‡æ¯ç›®è‡³è¾¾èµ°ç§¯ç¤ºè®®å£°æŠ¥æ–—å®Œç±»å…«ç¦»ååç¡®æ‰ç§‘å¼ ä¿¡é©¬èŠ‚è¯ç±³æ•´ç©ºå…ƒå†µä»Šé›†æ¸©ä¼ åœŸè®¸æ­¥ç¾¤å¹¿çŸ³è®°éœ€æ®µç ”ç•Œæ‹‰æ—å¾‹å«ä¸”ç©¶è§‚è¶Šç»‡è£…å½±ç®—ä½æŒéŸ³ä¼—ä¹¦å¸ƒå¤å®¹å„¿é¡»é™…å•†ééªŒè¿æ–­æ·±éš¾è¿‘çŸ¿åƒå‘¨å§”ç´ æŠ€å¤‡åŠåŠé’çœåˆ—ä¹ å“çº¦æ”¯èˆ¬å²æ„ŸåŠ³ä¾¿å›¢å¾€é…¸å†å¸‚å…‹ä½•é™¤æ¶ˆæ„åºœç§°å¤ªå‡†ç²¾å€¼å·ç‡æ—ç»´åˆ’é€‰æ ‡å†™å­˜å€™æ¯›äº²å¿«æ•ˆæ–¯é™¢æŸ¥æ±Ÿå‹çœ¼ç‹æŒ‰æ ¼å…»æ˜“ç½®æ´¾å±‚ç‰‡å§‹å´ä¸“çŠ¶è‚²å‚äº¬è¯†é€‚å±åœ†åŒ…ç«ä½è°ƒæ»¡å¿å±€ç…§å‚çº¢ç»†å¼•å¬è¯¥é“ä»·ä¸¥é¾™é£';

        function generateRandomString() {
            const length = parseInt(document.getElementById('length').value);
            
            if (!length || length < 1) {
                alert('è¯·è¾“å…¥æœ‰æ•ˆçš„å­—ç¬¦é•¿åº¦ï¼ˆè‡³å°‘ä¸º1ï¼‰');
                return;
            }

            if (length > 10000) {
                alert('å­—ç¬¦é•¿åº¦ä¸èƒ½è¶…è¿‡10000');
                return;
            }

            const uppercase = document.getElementById('uppercase').checked;
            const lowercase = document.getElementById('lowercase').checked;
            const numbers = document.getElementById('numbers').checked;
            const symbols = document.getElementById('symbols').checked;
            const chinese = document.getElementById('chinese').checked;

            if (!uppercase && !lowercase && !numbers && !symbols && !chinese) {
                alert('è¯·è‡³å°‘é€‰æ‹©ä¸€ç§å­—ç¬¦ç±»å‹');
                return;
            }

            let charset = '';
            if (uppercase) charset += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            if (lowercase) charset += 'abcdefghijklmnopqrstuvwxyz';
            if (numbers) charset += '0123456789';
            if (symbols) charset += '!@#$%^&*()_+-=[]{}|;:,.<>?';
            if (chinese) charset += commonChinese;

            let result = '';
            for (let i = 0; i < length; i++) {
                const randomIndex = Math.floor(Math.random() * charset.length);
                result += charset[randomIndex];
            }

            document.getElementById('result').textContent = result;
        }

        document.getElementById('length').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') generateRandomString();
        });

        // ========== JSONæ ¼å¼åŒ– ==========
        function formatJSON() {
            const input = document.getElementById('jsonInput').value.trim();
            const output = document.getElementById('jsonOutput');
            const error = document.getElementById('jsonError');
            
            error.textContent = '';
            
            if (!input) {
                error.textContent = 'è¯·è¾“å…¥JSONæ•°æ®';
                return;
            }

            try {
                const parsed = JSON.parse(input);
                output.value = JSON.stringify(parsed, null, 2);
            } catch (e) {
                error.textContent = 'âŒ JSONè§£æé”™è¯¯: ' + e.message;
                output.value = '';
            }
        }

        function compressJSON() {
            const input = document.getElementById('jsonInput').value.trim();
            const output = document.getElementById('jsonOutput');
            const error = document.getElementById('jsonError');
            
            error.textContent = '';
            
            if (!input) {
                error.textContent = 'è¯·è¾“å…¥JSONæ•°æ®';
                return;
            }

            try {
                const parsed = JSON.parse(input);
                output.value = JSON.stringify(parsed);
            } catch (e) {
                error.textContent = 'âŒ JSONè§£æé”™è¯¯: ' + e.message;
                output.value = '';
            }
        }

        function clearJSON() {
            document.getElementById('jsonInput').value = '';
            document.getElementById('jsonOutput').value = '';
            document.getElementById('jsonError').textContent = '';
        }

        // ========== Base64ç¼–è§£ç  ==========
        function encodeBase64() {
            const input = document.getElementById('base64Input').value;
            const output = document.getElementById('base64Output');
            const error = document.getElementById('base64Error');
            
            error.textContent = '';
            
            if (!input) {
                error.textContent = 'è¯·è¾“å…¥è¦ç¼–ç çš„æ–‡æœ¬';
                return;
            }

            try {
                output.value = btoa(unescape(encodeURIComponent(input)));
            } catch (e) {
                error.textContent = 'âŒ ç¼–ç å¤±è´¥: ' + e.message;
            }
        }

        function decodeBase64() {
            const input = document.getElementById('base64Input').value.trim();
            const output = document.getElementById('base64Output');
            const error = document.getElementById('base64Error');
            
            error.textContent = '';
            
            if (!input) {
                error.textContent = 'è¯·è¾“å…¥è¦è§£ç çš„Base64å­—ç¬¦ä¸²';
                return;
            }

            try {
                output.value = decodeURIComponent(escape(atob(input)));
            } catch (e) {
                error.textContent = 'âŒ è§£ç å¤±è´¥: æ— æ•ˆçš„Base64å­—ç¬¦ä¸²';
            }
        }

        function clearBase64() {
            document.getElementById('base64Input').value = '';
            document.getElementById('base64Output').value = '';
            document.getElementById('base64Error').textContent = '';
        }

        // ========== æ—¶é—´æˆ³è½¬æ¢ ==========
        function convertTimestamp() {
            let timestamp = document.getElementById('timestampInput').value.trim();
            const result = document.getElementById('timestampResult');
            
            if (!timestamp) {
                timestamp = Date.now();
            } else {
                timestamp = parseInt(timestamp);
                if (isNaN(timestamp)) {
                    result.textContent = 'âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„æ—¶é—´æˆ³';
                    return;
                }
            }

            const date = new Date(timestamp);
            result.innerHTML = `
                <strong>æ—¶é—´æˆ³ï¼š</strong>${timestamp}<br>
                <strong>åŒ—äº¬æ—¶é—´ï¼š</strong>${date.toLocaleString('zh-CN', { timeZone: 'Asia/Shanghai' })}<br>
                <strong>UTCæ—¶é—´ï¼š</strong>${date.toUTCString()}<br>
                <strong>ISOæ ¼å¼ï¼š</strong>${date.toISOString()}
            `;
        }

        function getCurrentTimestamp() {
            const timestamp = Date.now();
            document.getElementById('timestampInput').value = timestamp;
            convertTimestamp();
        }

        function convertDateToTimestamp() {
            const dateInput = document.getElementById('dateInput').value;
            const result = document.getElementById('dateResult');
            
            if (!dateInput) {
                result.textContent = 'âŒ è¯·é€‰æ‹©æ—¥æœŸæ—¶é—´';
                return;
            }

            const timestamp = new Date(dateInput).getTime();
            result.innerHTML = `
                <strong>æ—¶é—´æˆ³ï¼ˆæ¯«ç§’ï¼‰ï¼š</strong>${timestamp}<br>
                <strong>æ—¶é—´æˆ³ï¼ˆç§’ï¼‰ï¼š</strong>${Math.floor(timestamp / 1000)}
            `;
        }

        // ========== URLç¼–è§£ç  ==========
        function encodeURL() {
            const input = document.getElementById('urlInput').value;
            const output = document.getElementById('urlOutput');
            const error = document.getElementById('urlError');
            
            error.textContent = '';
            
            if (!input) {
                error.textContent = 'è¯·è¾“å…¥è¦ç¼–ç çš„URLæˆ–æ–‡æœ¬';
                return;
            }

            try {
                output.value = encodeURIComponent(input);
            } catch (e) {
                error.textContent = 'âŒ ç¼–ç å¤±è´¥: ' + e.message;
            }
        }

        function decodeURL() {
            const input = document.getElementById('urlInput').value.trim();
            const output = document.getElementById('urlOutput');
            const error = document.getElementById('urlError');
            
            error.textContent = '';
            
            if (!input) {
                error.textContent = 'è¯·è¾“å…¥è¦è§£ç çš„URL';
                return;
            }

            try {
                output.value = decodeURIComponent(input);
            } catch (e) {
                error.textContent = 'âŒ è§£ç å¤±è´¥: ' + e.message;
            }
        }

        function clearURL() {
            document.getElementById('urlInput').value = '';
            document.getElementById('urlOutput').value = '';
            document.getElementById('urlError').textContent = '';
        }

        // ========== å“ˆå¸ŒåŠ å¯† ==========
        function generateHash() {
            const input = document.getElementById('hashInput').value;
            const output = document.getElementById('hashOutput');
            const algo = document.querySelector('input[name="hashAlgo"]:checked').value;
            
            if (!input) {
                output.textContent = 'âŒ è¯·è¾“å…¥è¦åŠ å¯†çš„æ–‡æœ¬';
                return;
            }

            let hash;
            switch(algo) {
                case 'md5':
                    hash = CryptoJS.MD5(input).toString();
                    break;
                case 'sha1':
                    hash = CryptoJS.SHA1(input).toString();
                    break;
                case 'sha256':
                    hash = CryptoJS.SHA256(input).toString();
                    break;
            }

            output.innerHTML = `
                <strong>ç®—æ³•ï¼š</strong>${algo.toUpperCase()}<br>
                <strong>å“ˆå¸Œå€¼ï¼š</strong>${hash}
            `;
        }

        function clearHash() {
            document.getElementById('hashInput').value = '';
            document.getElementById('hashOutput').textContent = 'è¾“å…¥æ–‡æœ¬åç‚¹å‡»ç”Ÿæˆ';
        }

        // ========== æˆå¯¹ç»„åˆæµ‹è¯• (Pairwise) ==========
        // ç®€åŒ–çš„æˆå¯¹ç»„åˆç®—æ³•å®ç°
        function generatePairwise() {
            const input = document.getElementById('pairwiseInput').value.trim();
            const output = document.getElementById('pairwiseOutput');
            const error = document.getElementById('pairwiseError');
            const stats = document.getElementById('pairwiseStats');
            const statsText = document.getElementById('pairwiseStatsText');
            const order = parseInt(document.querySelector('input[name="pairwiseOrder"]:checked').value);
            
            error.textContent = '';
            stats.style.display = 'none';
            
            if (!input) {
                error.textContent = 'è¯·è¾“å…¥æµ‹è¯•å‚æ•°é…ç½®';
                return;
            }

            try {
                // è§£æè¾“å…¥å‚æ•°
                const parameters = [];
                const lines = input.split('\n').filter(line => line.trim());
                
                for (const line of lines) {
                    const parts = line.split(':');
                    if (parts.length !== 2) {
                        error.textContent = 'âŒ æ ¼å¼é”™è¯¯ï¼šæ¯è¡Œæ ¼å¼åº”ä¸º "å‚æ•°å: å€¼1, å€¼2, å€¼3"';
                        return;
                    }
                    
                    const paramName = parts[0].trim();
                    const values = parts[1].split(',').map(v => v.trim()).filter(v => v);
                    
                    if (values.length === 0) {
                        error.textContent = `âŒ å‚æ•° "${paramName}" æ²¡æœ‰å€¼`;
                        return;
                    }
                    
                    parameters.push({ name: paramName, values: values });
                }

                if (parameters.length < 2) {
                    error.textContent = 'âŒ è‡³å°‘éœ€è¦2ä¸ªå‚æ•°';
                    return;
                }

                // ç”Ÿæˆæµ‹è¯•ç”¨ä¾‹
                let testCases;
                if (order === 2) {
                    testCases = generatePairwiseCombinations(parameters);
                } else {
                    testCases = generate3WayCombinations(parameters);
                }

                // è®¡ç®—å…¨é‡ç»„åˆæ•°
                const fullCombinations = parameters.reduce((acc, param) => acc * param.values.length, 1);

                // æ ¼å¼åŒ–è¾“å‡º
                const header = parameters.map(p => p.name).join('\t');
                const rows = testCases.map((testCase, index) => {
                    return `${index + 1}\t${testCase.join('\t')}`;
                }).join('\n');

                output.value = `ç¼–å·\t${header}\n${rows}`;

                // æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯
                stats.style.display = 'block';
                statsText.textContent = `ç”Ÿæˆ ${testCases.length} ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼ˆå…¨é‡ç»„åˆéœ€è¦ ${fullCombinations} ä¸ªï¼Œä¼˜åŒ–ç‡ ${((1 - testCases.length/fullCombinations) * 100).toFixed(1)}%ï¼‰`;

            } catch (e) {
                error.textContent = 'âŒ ç”Ÿæˆå¤±è´¥: ' + e.message;
            }
        }

        // ä¸¤ä¸¤ç»„åˆç®—æ³•ï¼ˆè´ªå©ªç®—æ³•ï¼‰
        function generatePairwiseCombinations(parameters) {
            // ç”Ÿæˆæ‰€æœ‰éœ€è¦è¦†ç›–çš„é…å¯¹
            const pairs = [];
            for (let i = 0; i < parameters.length; i++) {
                for (let j = i + 1; j < parameters.length; j++) {
                    for (const val1 of parameters[i].values) {
                        for (const val2 of parameters[j].values) {
                            pairs.push({ indices: [i, j], values: [val1, val2] });
                        }
                    }
                }
            }

            const testCases = [];
            const uncoveredPairs = new Set(pairs.map((p, idx) => idx));

            // è´ªå©ªç®—æ³•ï¼šæ¯æ¬¡é€‰æ‹©è¦†ç›–æœ€å¤šæœªè¦†ç›–é…å¯¹çš„æµ‹è¯•ç”¨ä¾‹
            while (uncoveredPairs.size > 0) {
                let bestCase = null;
                let maxCoverage = 0;

                // å°è¯•å¤šä¸ªéšæœºç»„åˆï¼Œé€‰æ‹©è¦†ç›–æœ€å¤šçš„
                for (let attempt = 0; attempt < 50; attempt++) {
                    const candidate = parameters.map(p => p.values[Math.floor(Math.random() * p.values.length)]);
                    const coverage = countCoverage(candidate, pairs, uncoveredPairs, parameters);

                    if (coverage > maxCoverage) {
                        maxCoverage = coverage;
                        bestCase = candidate;
                    }
                }

                // å¦‚æœéšæœºç”Ÿæˆæ•ˆæœä¸å¥½ï¼Œå°è¯•é’ˆå¯¹æ€§æ„é€ 
                if (maxCoverage === 0 && uncoveredPairs.size > 0) {
                    const targetPairIdx = Array.from(uncoveredPairs)[0];
                    const targetPair = pairs[targetPairIdx];
                    bestCase = constructCaseForPair(targetPair, parameters);
                }

                if (bestCase) {
                    testCases.push(bestCase);
                    // æ›´æ–°æœªè¦†ç›–çš„é…å¯¹
                    updateCoverage(bestCase, pairs, uncoveredPairs, parameters);
                }

                // é˜²æ­¢æ— é™å¾ªç¯
                if (testCases.length > parameters.reduce((acc, p) => acc * p.values.length, 1)) {
                    break;
                }
            }

            return testCases;
        }

        // ä¸‰å› å­ç»„åˆç®—æ³•ï¼ˆç®€åŒ–ç‰ˆï¼‰
        function generate3WayCombinations(parameters) {
            if (parameters.length < 3) {
                return generatePairwiseCombinations(parameters);
            }

            // ç”Ÿæˆæ‰€æœ‰éœ€è¦è¦†ç›–çš„ä¸‰å…ƒç»„
            const triples = [];
            for (let i = 0; i < parameters.length; i++) {
                for (let j = i + 1; j < parameters.length; j++) {
                    for (let k = j + 1; k < parameters.length; k++) {
                        for (const val1 of parameters[i].values) {
                            for (const val2 of parameters[j].values) {
                                for (const val3 of parameters[k].values) {
                                    triples.push({ indices: [i, j, k], values: [val1, val2, val3] });
                                }
                            }
                        }
                    }
                }
            }

            const testCases = [];
            const uncoveredTriples = new Set(triples.map((t, idx) => idx));

            while (uncoveredTriples.size > 0) {
                let bestCase = null;
                let maxCoverage = 0;

                for (let attempt = 0; attempt < 100; attempt++) {
                    const candidate = parameters.map(p => p.values[Math.floor(Math.random() * p.values.length)]);
                    const coverage = count3WayCoverage(candidate, triples, uncoveredTriples, parameters);

                    if (coverage > maxCoverage) {
                        maxCoverage = coverage;
                        bestCase = candidate;
                    }
                }

                if (maxCoverage === 0 && uncoveredTriples.size > 0) {
                    const targetTripleIdx = Array.from(uncoveredTriples)[0];
                    const targetTriple = triples[targetTripleIdx];
                    bestCase = constructCaseFor3Way(targetTriple, parameters);
                }

                if (bestCase) {
                    testCases.push(bestCase);
                    update3WayCoverage(bestCase, triples, uncoveredTriples, parameters);
                }

                if (testCases.length > parameters.reduce((acc, p) => acc * p.values.length, 1)) {
                    break;
                }
            }

            return testCases;
        }

        // è¾…åŠ©å‡½æ•°ï¼šè®¡ç®—æµ‹è¯•ç”¨ä¾‹è¦†ç›–çš„é…å¯¹æ•°
        function countCoverage(testCase, pairs, uncoveredPairs, parameters) {
            let count = 0;
            uncoveredPairs.forEach(idx => {
                const pair = pairs[idx];
                if (testCase[pair.indices[0]] === pair.values[0] && 
                    testCase[pair.indices[1]] === pair.values[1]) {
                    count++;
                }
            });
            return count;
        }

        // è¾…åŠ©å‡½æ•°ï¼šæ›´æ–°è¦†ç›–çŠ¶æ€
        function updateCoverage(testCase, pairs, uncoveredPairs, parameters) {
            const toRemove = [];
            uncoveredPairs.forEach(idx => {
                const pair = pairs[idx];
                if (testCase[pair.indices[0]] === pair.values[0] && 
                    testCase[pair.indices[1]] === pair.values[1]) {
                    toRemove.push(idx);
                }
            });
            toRemove.forEach(idx => uncoveredPairs.delete(idx));
        }

        // è¾…åŠ©å‡½æ•°ï¼šä¸ºç‰¹å®šé…å¯¹æ„é€ æµ‹è¯•ç”¨ä¾‹
        function constructCaseForPair(pair, parameters) {
            const testCase = parameters.map(p => p.values[0]);
            testCase[pair.indices[0]] = pair.values[0];
            testCase[pair.indices[1]] = pair.values[1];
            return testCase;
        }

        // è¾…åŠ©å‡½æ•°ï¼šè®¡ç®—ä¸‰å› å­è¦†ç›–
        function count3WayCoverage(testCase, triples, uncoveredTriples, parameters) {
            let count = 0;
            uncoveredTriples.forEach(idx => {
                const triple = triples[idx];
                if (testCase[triple.indices[0]] === triple.values[0] && 
                    testCase[triple.indices[1]] === triple.values[1] &&
                    testCase[triple.indices[2]] === triple.values[2]) {
                    count++;
                }
            });
            return count;
        }

        // è¾…åŠ©å‡½æ•°ï¼šæ›´æ–°ä¸‰å› å­è¦†ç›–
        function update3WayCoverage(testCase, triples, uncoveredTriples, parameters) {
            const toRemove = [];
            uncoveredTriples.forEach(idx => {
                const triple = triples[idx];
                if (testCase[triple.indices[0]] === triple.values[0] && 
                    testCase[triple.indices[1]] === triple.values[1] &&
                    testCase[triple.indices[2]] === triple.values[2]) {
                    toRemove.push(idx);
                }
            });
            toRemove.forEach(idx => uncoveredTriples.delete(idx));
        }

        // è¾…åŠ©å‡½æ•°ï¼šä¸ºç‰¹å®šä¸‰å…ƒç»„æ„é€ æµ‹è¯•ç”¨ä¾‹
        function constructCaseFor3Way(triple, parameters) {
            const testCase = parameters.map(p => p.values[0]);
            testCase[triple.indices[0]] = triple.values[0];
            testCase[triple.indices[1]] = triple.values[1];
            testCase[triple.indices[2]] = triple.values[2];
            return testCase;
        }

        // åŠ è½½ç¤ºä¾‹
        function loadPairwiseExample() {
            const example = `æµè§ˆå™¨: Chrome, Firefox, Safari, Edge
æ“ä½œç³»ç»Ÿ: Windows, macOS, Linux
åˆ†è¾¨ç‡: 1920x1080, 1366x768, 2560x1440
è¯­è¨€: ä¸­æ–‡, è‹±æ–‡, æ—¥æ–‡`;
            document.getElementById('pairwiseInput').value = example;
        }

        // æ¸…ç©º
        function clearPairwise() {
            document.getElementById('pairwiseInput').value = '';
            document.getElementById('pairwiseOutput').value = '';
            document.getElementById('pairwiseError').textContent = '';
            document.getElementById('pairwiseStats').style.display = 'none';
        }

        // å¯¼å‡ºCSV
        function exportPairwiseCSV() {
            const output = document.getElementById('pairwiseOutput').value;
            
            if (!output) {
                alert('æ²¡æœ‰å¯å¯¼å‡ºçš„æµ‹è¯•ç”¨ä¾‹');
                return;
            }

            // å°†åˆ¶è¡¨ç¬¦æ›¿æ¢ä¸ºé€—å·ï¼ˆCSVæ ¼å¼ï¼‰
            const csvContent = output.replace(/\t/g, ',');
            
            // åˆ›å»ºä¸‹è½½
            const blob = new Blob(['\ufeff' + csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            
            link.setAttribute('href', url);
            link.setAttribute('download', 'pairwise_testcases_' + new Date().getTime() + '.csv');
            link.style.visibility = 'hidden';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showToast('CSVæ–‡ä»¶å·²å¯¼å‡ºï¼');
        }

        // ========== æ—¶é—´å·®è®¡ç®— ==========
        // è®¾ç½®å½“å‰æ—¶é—´
        function setCurrentTime(inputId) {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hour = String(now.getHours()).padStart(2, '0');
            const minute = String(now.getMinutes()).padStart(2, '0');
            const second = String(now.getSeconds()).padStart(2, '0');
            
            const timeString = `${year}-${month}-${day} ${hour}:${minute}:${second}`;
            document.getElementById(inputId).value = timeString;
        }

        // è§£ææ—¶é—´å­—ç¬¦ä¸²ï¼ˆä¸¥æ ¼éªŒè¯ç‰ˆï¼‰
        function parseTimeString(timeStr) {
            timeStr = timeStr.trim().replace(/\//g, '-');
            
            const patterns = [
                {
                    regex: /^(\d{4})-(\d{1,2})-(\d{1,2})\s+(\d{1,2}):(\d{1,2}):(\d{1,2})$/,
                    hasTime: true
                },
                {
                    regex: /^(\d{4})-(\d{1,2})-(\d{1,2})$/,
                    hasTime: false
                }
            ];
            
            for (const pattern of patterns) {
                const match = timeStr.match(pattern.regex);
                if (match) {
                    const year = parseInt(match[1]);
                    const month = parseInt(match[2]);
                    const day = parseInt(match[3]);
                    let hour = 0, minute = 0, second = 0;
                    
                    if (pattern.hasTime) {
                        hour = parseInt(match[4]);
                        minute = parseInt(match[5]);
                        second = parseInt(match[6]);
                    }
                    
                    const validation = validateDateTime(year, month, day, hour, minute, second);
                    if (!validation.valid) {
                        throw new Error(validation.error);
                    }
                    
                    const date = new Date(year, month - 1, day, hour, minute, second);
                    
                    if (date.getFullYear() !== year || 
                        date.getMonth() !== month - 1 || 
                        date.getDate() !== day ||
                        (pattern.hasTime && (date.getHours() !== hour || date.getMinutes() !== minute || date.getSeconds() !== second))) {
                        throw new Error('æ—¥æœŸä¸å­˜åœ¨æˆ–æ— æ•ˆ');
                    }
                    
                    return date;
                }
            }
            
            throw new Error('æ—¶é—´æ ¼å¼ä¸æ­£ç¡®');
        }

        // ä¸¥æ ¼éªŒè¯æ—¥æœŸæ—¶é—´å„å­—æ®µ
        function validateDateTime(year, month, day, hour, minute, second) {
            if (year < 1000 || year > 9999) {
                return { valid: false, error: 'å¹´ä»½å¿…é¡»åœ¨1000-9999ä¹‹é—´' };
            }
            
            if (month < 1 || month > 12) {
                return { valid: false, error: 'æœˆä»½å¿…é¡»åœ¨1-12ä¹‹é—´' };
            }
            
            if (hour < 0 || hour > 23) {
                return { valid: false, error: 'å°æ—¶å¿…é¡»åœ¨0-23ä¹‹é—´' };
            }
            
            if (minute < 0 || minute > 59) {
                return { valid: false, error: 'åˆ†é’Ÿå¿…é¡»åœ¨0-59ä¹‹é—´' };
            }
            
            if (second < 0 || second > 59) {
                return { valid: false, error: 'ç§’å¿…é¡»åœ¨0-59ä¹‹é—´' };
            }
            
            const maxDay = getMaxDayInMonth(year, month);
            if (day < 1 || day > maxDay) {
                return { valid: false, error: `${month}æœˆçš„æ—¥æœŸå¿…é¡»åœ¨1-${maxDay}ä¹‹é—´` };
            }
            
            return { valid: true };
        }

        // è·å–æŒ‡å®šå¹´æœˆçš„æœ€å¤§å¤©æ•°
        function getMaxDayInMonth(year, month) {
            const daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            
            if (month === 2) {
                return isLeapYear(year) ? 29 : 28;
            }
            
            return daysInMonth[month - 1];
        }

        // åˆ¤æ–­æ˜¯å¦ä¸ºé—°å¹´
        function isLeapYear(year) {
            return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
        }

        // è®¡ç®—æ—¶é—´å·®
        function calculateTimeDifference() {
            const startTimeStr = document.getElementById('startTime').value.trim();
            const endTimeStr = document.getElementById('endTime').value.trim();
            const result = document.getElementById('timeDiffResult');
            const error = document.getElementById('timeDiffError');
            
            error.textContent = '';
            
            if (!startTimeStr || !endTimeStr) {
                error.textContent = 'è¯·è¾“å…¥å¼€å§‹æ—¶é—´å’Œç»“æŸæ—¶é—´';
                return;
            }
            
            let startTime, endTime;
            
            try {
                startTime = parseTimeString(startTimeStr);
            } catch (e) {
                error.textContent = 'âŒ å¼€å§‹æ—¶é—´é”™è¯¯ï¼š' + e.message;
                return;
            }
            
            try {
                endTime = parseTimeString(endTimeStr);
            } catch (e) {
                error.textContent = 'âŒ ç»“æŸæ—¶é—´é”™è¯¯ï¼š' + e.message;
                return;
            }
            
            if (isNaN(startTime.getTime())) {
                error.textContent = 'âŒ å¼€å§‹æ—¶é—´æ— æ•ˆ';
                return;
            }
            
            if (isNaN(endTime.getTime())) {
                error.textContent = 'âŒ ç»“æŸæ—¶é—´æ— æ•ˆ';
                return;
            }
            
            // è®¡ç®—æ—¶é—´å·®ï¼ˆæ¯«ç§’ï¼‰
            let diffMs = endTime.getTime() - startTime.getTime();
            const isNegative = diffMs < 0;
            diffMs = Math.abs(diffMs);
            
            // è½¬æ¢ä¸ºå„ç§å•ä½
            const diffSeconds = Math.floor(diffMs / 1000);
            const diffMinutes = Math.floor(diffSeconds / 60);
            const diffHours = Math.floor(diffMinutes / 60);
            const diffDays = Math.floor(diffHours / 24);
            
            // è®¡ç®—è¯¦ç»†çš„æ—¶é—´å·®
            const days = Math.floor(diffMs / (1000 * 60 * 60 * 24));
            const hours = Math.floor((diffMs % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((diffMs % (1000 * 60)) / 1000);
            const milliseconds = diffMs % 1000;
            
            // è®¡ç®—å‘¨ã€æœˆã€å¹´ï¼ˆè¿‘ä¼¼å€¼ï¼‰
            const weeks = Math.floor(diffDays / 7);
            const months = Math.floor(diffDays / 30);
            const years = Math.floor(diffDays / 365);
            
            // æ ¼å¼åŒ–è¾“å‡º
            const prefix = isNegative ? 'ï¼ˆç»“æŸæ—¶é—´æ—©äºå¼€å§‹æ—¶é—´ï¼Œæ—¶é—´å·®ä¸ºè´Ÿå€¼ï¼‰<br>' : '';
            const sign = isNegative ? '-' : '';
            
            result.innerHTML = `
                ${prefix}
                <strong>ğŸ“… æ ‡å‡†æ ¼å¼ï¼š</strong>${sign}${days}å¤© ${String(hours).padStart(2, '0')}æ—¶ ${String(minutes).padStart(2, '0')}åˆ† ${String(seconds).padStart(2, '0')}ç§’<br><br>
                
                <strong>ğŸ“Š è¯¦ç»†ä¿¡æ¯ï¼š</strong><br>
                â€¢ æ€»å¤©æ•°ï¼š${sign}${diffDays} å¤©<br>
                â€¢ æ€»å°æ—¶æ•°ï¼š${sign}${diffHours} å°æ—¶<br>
                â€¢ æ€»åˆ†é’Ÿæ•°ï¼š${sign}${diffMinutes} åˆ†é’Ÿ<br>
                â€¢ æ€»ç§’æ•°ï¼š${sign}${diffSeconds} ç§’<br>
                â€¢ æ€»æ¯«ç§’æ•°ï¼š${sign}${diffMs} æ¯«ç§’<br><br>
                
                <strong>ğŸ—“ï¸ è¿‘ä¼¼æ¢ç®—ï¼š</strong><br>
                â€¢ çº¦ ${sign}${weeks} å‘¨<br>
                â€¢ çº¦ ${sign}${months} ä¸ªæœˆ<br>
                â€¢ çº¦ ${sign}${years} å¹´<br><br>
                
                <strong>â° å¼€å§‹æ—¶é—´ï¼š</strong>${startTime.toLocaleString('zh-CN', { timeZone: 'Asia/Shanghai' })}<br>
                <strong>â° ç»“æŸæ—¶é—´ï¼š</strong>${endTime.toLocaleString('zh-CN', { timeZone: 'Asia/Shanghai' })}
            `;
        }

        // åŠ è½½ç¤ºä¾‹
        function loadTimeDiffExample() {
            document.getElementById('startTime').value = '2024-10-16 14:37:49';
            document.getElementById('endTime').value = '2025-12-01 14:37:50';
        }

        // æ¸…ç©º
        function clearTimeDiff() {
            document.getElementById('startTime').value = '';
            document.getElementById('endTime').value = '';
            document.getElementById('timeDiffResult').textContent = 'è¾“å…¥ä¸¤ä¸ªæ—¶é—´åç‚¹å‡»è®¡ç®—';
            document.getElementById('timeDiffError').textContent = '';
        }

        // ========== æµ‹è¯•æ–‡ä»¶ç”Ÿæˆå™¨ ==========
        
        // æ–‡ä»¶æ ¼å¼é…ç½®
        const FILE_FORMATS = {
            txt: { ext: 'txt', mime: 'text/plain', name: 'TXTæ–‡æœ¬', binary: false },
            csv: { ext: 'csv', mime: 'text/csv', name: 'CSVæ–‡ä»¶', binary: false },
            json: { ext: 'json', mime: 'application/json', name: 'JSONæ–‡ä»¶', binary: false },
            xml: { ext: 'xml', mime: 'application/xml', name: 'XMLæ–‡ä»¶', binary: false },
            html: { ext: 'html', mime: 'text/html', name: 'HTMLæ–‡ä»¶', binary: false },
            log: { ext: 'log', mime: 'text/plain', name: 'LOGæ—¥å¿—', binary: false },
            sql: { ext: 'sql', mime: 'application/sql', name: 'SQLè„šæœ¬', binary: false },
            md: { ext: 'md', mime: 'text/markdown', name: 'Markdownæ–‡æ¡£', binary: false },
            png: { ext: 'png', mime: 'image/png', name: 'PNGå›¾ç‰‡', binary: true },
            jpg: { ext: 'jpg', mime: 'image/jpeg', name: 'JPGå›¾ç‰‡', binary: true },
            gif: { ext: 'gif', mime: 'image/gif', name: 'GIFå›¾ç‰‡', binary: true },
            bmp: { ext: 'bmp', mime: 'image/bmp', name: 'BMPå›¾ç‰‡', binary: true },
            svg: { ext: 'svg', mime: 'image/svg+xml', name: 'SVGçŸ¢é‡å›¾', binary: false },
            pdf: { ext: 'pdf', mime: 'application/pdf', name: 'PDFæ–‡æ¡£', binary: true },
            docx: { ext: 'docx', mime: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', name: 'Wordæ–‡æ¡£', binary: true },
            xlsx: { ext: 'xlsx', mime: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', name: 'Excelè¡¨æ ¼', binary: true },
            pptx: { ext: 'pptx', mime: 'application/vnd.openxmlformats-officedocument.presentationml.presentation', name: 'PowerPointæ¼”ç¤º', binary: true },
            zip: { ext: 'zip', mime: 'application/zip', name: 'ZIPå‹ç¼©åŒ…', binary: true },
            bin: { ext: 'bin', mime: 'application/octet-stream', name: 'äºŒè¿›åˆ¶æ–‡ä»¶', binary: true },
            dat: { ext: 'dat', mime: 'application/octet-stream', name: 'DATæ•°æ®æ–‡ä»¶', binary: true },
            custom: { ext: 'dat', mime: 'application/octet-stream', name: 'è‡ªå®šä¹‰æ ¼å¼', binary: true }
        };
        
        // æ›´æ–°æ–‡ä»¶æ ¼å¼UI
        function updateFileFormatUI() {
            const format = document.getElementById('fileFormat').value;
            const customExtGroup = document.getElementById('customExtGroup');
            
            // æ˜¾ç¤º/éšè—è‡ªå®šä¹‰æ‰©å±•åè¾“å…¥æ¡†
            if (format === 'custom') {
                customExtGroup.style.display = 'block';
            } else {
                customExtGroup.style.display = 'none';
            }
        }
        
        // å¿«é€Ÿè®¾ç½®æ–‡ä»¶å¤§å°
        function setQuickSize(size, unit) {
            document.getElementById('fileSize').value = size;
            document.getElementById('sizeUnit').value = unit;
        }
        
        // æ˜¾ç¤º/éšè—æ‰¹é‡ç”Ÿæˆé…ç½®
        function generateBatch() {
            const batchConfig = document.getElementById('batchConfigGroup');
            batchConfig.style.display = batchConfig.style.display === 'none' ? 'block' : 'none';
        }
        
        // å–æ¶ˆæ‰¹é‡ç”Ÿæˆ
        function cancelBatch() {
            document.getElementById('batchConfigGroup').style.display = 'none';
        }
        
        // æ‰§è¡Œæ‰¹é‡ç”Ÿæˆ
        async function executeBatchGeneration() {
            const sizes = [
                { id: 'batch10KB', size: 10, unit: 'KB' },
                { id: 'batch100KB', size: 100, unit: 'KB' },
                { id: 'batch1MB', size: 1, unit: 'MB' },
                { id: 'batch10MB', size: 10, unit: 'MB' },
                { id: 'batch100MB', size: 100, unit: 'MB' },
                { id: 'batch500MB', size: 500, unit: 'MB' }
            ];
            
            const selected = sizes.filter(s => document.getElementById(s.id).checked);
            
            if (selected.length === 0) {
                alert('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªæ–‡ä»¶å¤§å°');
                return;
            }
            
            const format = document.getElementById('fileFormat').value;
            const baseName = document.getElementById('fileName').value.trim() || 'test';
            const contentType = document.querySelector('input[name="contentType"]:checked').value;
            
            cancelBatch();
            
            for (let i = 0; i < selected.length; i++) {
                const item = selected[i];
                const fileName = `${baseName}_${item.size}${item.unit}`;
                
                // ä¸´æ—¶è®¾ç½®å¤§å°
                document.getElementById('fileSize').value = item.size;
                document.getElementById('sizeUnit').value = item.unit;
                
                // ç”Ÿæˆæ–‡ä»¶
                await generateAndDownloadFile(true);
                
                // ç­‰å¾…ä¸€ä¸‹å†ç”Ÿæˆä¸‹ä¸€ä¸ª
                if (i < selected.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
            }
            
            showToast('æ‰¹é‡ç”Ÿæˆå®Œæˆï¼');
        }
        
        // ç”Ÿæˆå¹¶ä¸‹è½½æ–‡ä»¶ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
        async function generateAndDownloadFile(isBatch = false) {
            const sizeInput = parseFloat(document.getElementById('fileSize').value);
            const unit = document.getElementById('sizeUnit').value;
            const fileName = document.getElementById('fileName').value.trim() || 'test_file';
            const contentType = document.querySelector('input[name="contentType"]:checked').value;
            const format = document.getElementById('fileFormat').value;
            const result = document.getElementById('fileGenResult');
            const error = document.getElementById('fileGenError');
            const progressContainer = document.getElementById('progressContainer');
            
            error.textContent = '';
            
            if (!sizeInput || sizeInput <= 0) {
                error.textContent = 'è¯·è¾“å…¥æœ‰æ•ˆçš„æ–‡ä»¶å¤§å°ï¼ˆå¤§äº0ï¼‰';
                return;
            }
            
            // è·å–æ–‡ä»¶æ‰©å±•å
            let fileExt = FILE_FORMATS[format]?.ext || 'dat';
            let mimeType = FILE_FORMATS[format]?.mime || 'application/octet-stream';
            
            if (format === 'custom') {
                const customExt = document.getElementById('customExt').value.trim();
                if (customExt) {
                    fileExt = customExt.replace(/^\./, ''); // ç§»é™¤å¼€å¤´çš„ç‚¹
                } else {
                    error.textContent = 'è¯·è¾“å…¥è‡ªå®šä¹‰æ‰©å±•å';
                    return;
                }
            }
            
            // è®¡ç®—å­—èŠ‚æ•°
            let sizeInBytes = sizeInput;
            switch(unit) {
                case 'KB': sizeInBytes = sizeInput * 1024; break;
                case 'MB': sizeInBytes = sizeInput * 1024 * 1024; break;
                case 'GB': sizeInBytes = sizeInput * 1024 * 1024 * 1024; break;
            }
            
            // è½¯é™åˆ¶è­¦å‘Šï¼ˆ500MBï¼‰
            if (sizeInBytes > 500 * 1024 * 1024 && !isBatch) {
                const sizeStr = formatFileSize(sizeInBytes);
                const confirmed = confirm(`âš ï¸ æ–‡ä»¶å¤§å°ä¸º ${sizeStr}ï¼Œç”Ÿæˆå¯èƒ½éœ€è¦è¾ƒé•¿æ—¶é—´ã€‚\n\nâ€¢ å°äº100MBï¼šçº¦å‡ ç§’\nâ€¢ 100MB-1GBï¼šçº¦10-60ç§’\nâ€¢ å¤§äº1GBï¼šå¯èƒ½éœ€è¦æ•°åˆ†é’Ÿ\n\næ˜¯å¦ç»§ç»­ï¼Ÿ`);
                if (!confirmed) {
                    return;
                }
            }
            
            // æ ¹æ®æ–‡ä»¶å¤§å°é€‰æ‹©ç”Ÿæˆç­–ç•¥
            if (sizeInBytes < 50 * 1024 * 1024) {
                // å°æ–‡ä»¶ï¼ˆ<50MBï¼‰ï¼šä¸€æ¬¡æ€§ç”Ÿæˆ
                await generateSmallFile(sizeInBytes, fileName, fileExt, format, contentType, mimeType, result, error);
            } else {
                // å¤§æ–‡ä»¶ï¼ˆâ‰¥50MBï¼‰ï¼šæµå¼ç”Ÿæˆ
                await generateLargeFileStreaming(sizeInBytes, fileName, fileExt, format, contentType, mimeType, result, error, progressContainer);
            }
        }

        // å°æ–‡ä»¶ç”Ÿæˆï¼ˆä¸€æ¬¡æ€§ï¼‰
        async function generateSmallFile(sizeInBytes, fileName, fileExt, format, contentType, mimeType, result, error) {
            result.innerHTML = '<strong>â³ æ­£åœ¨ç”Ÿæˆæ–‡ä»¶...</strong>';
            
            setTimeout(() => {
                try {
                    const startTime = Date.now();
                    const content = generateFileContentByFormat(sizeInBytes, format, contentType);
                    const blob = new Blob([content], { type: mimeType });
                    downloadBlob(blob, fileName, fileExt);
                    
                    const endTime = Date.now();
                    showGenerationResult(blob.size, fileName, fileExt, format, contentType, (endTime - startTime) / 1000, result);
                } catch (e) {
                    error.textContent = 'âŒ æ–‡ä»¶ç”Ÿæˆå¤±è´¥: ' + e.message;
                    result.innerHTML = 'ç‚¹å‡»ç”ŸæˆæŒ‰é’®åˆ›å»ºæµ‹è¯•æ–‡ä»¶';
                }
            }, 50);
        }

        // å¤§æ–‡ä»¶æµå¼ç”Ÿæˆï¼ˆè¾¹ç”Ÿæˆè¾¹åˆå¹¶ï¼Œå‡å°‘å†…å­˜å ç”¨ï¼‰
        async function generateLargeFileStreaming(sizeInBytes, fileName, fileExt, format, contentType, mimeType, result, error, progressContainer) {
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            
            progressContainer.style.display = 'block';
            result.innerHTML = '<strong>â³ æ­£åœ¨ç”Ÿæˆå¤§æ–‡ä»¶ï¼Œè¯·ç¨å€™...</strong>';
            
            try {
                const startTime = Date.now();
                
                // å…³é”®ä¼˜åŒ–ï¼šåˆ†æ‰¹åˆå¹¶ï¼Œé¿å…å†…å­˜ç´¯ç§¯
                const batchSize = 10; // æ¯10ä¸ªchunkåˆå¹¶ä¸€æ¬¡
                const chunkSize = 2 * 1024 * 1024; // 2MB per chunk
                let allBlobs = []; // å­˜å‚¨åˆå¹¶åçš„Blob
                let tempChunks = []; // ä¸´æ—¶å­˜å‚¨å¾…åˆå¹¶çš„chunks
                let remainingSize = sizeInBytes;
                let processedSize = 0;
                
                // å¦‚æœæ˜¯ç»“æ„åŒ–æ ¼å¼ï¼Œå…ˆæ·»åŠ å¤´éƒ¨
                if (contentType === 'structured') {
                    const header = getFileHeader(format);
                    if (header) {
                        tempChunks.push(header);
                        processedSize += header.length;
                    }
                }
                
                while (remainingSize > 0) {
                    const currentChunkSize = Math.min(chunkSize, remainingSize);
                    
                    // è®©UIæœ‰æœºä¼šæ›´æ–°
                    if (tempChunks.length % 5 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                    
                    // ç”Ÿæˆchunk
                    const chunk = generateFileContentByFormat(currentChunkSize, format, contentType, true);
                    tempChunks.push(chunk);
                    
                    processedSize += currentChunkSize;
                    remainingSize -= currentChunkSize;
                    
                    // æ›´æ–°è¿›åº¦
                    const progress = Math.round((processedSize / sizeInBytes) * 100);
                    progressBar.style.width = progress + '%';
                    progressBar.textContent = progress + '%';
                    progressText.textContent = `å·²ç”Ÿæˆ: ${formatFileSize(processedSize)} / ${formatFileSize(sizeInBytes)}`;
                    
                    // å®šæœŸåˆå¹¶chunksï¼Œé‡Šæ”¾å†…å­˜
                    if (tempChunks.length >= batchSize || remainingSize === 0) {
                        const batchBlob = new Blob(tempChunks, { type: mimeType });
                        allBlobs.push(batchBlob);
                        tempChunks = []; // æ¸…ç©ºä¸´æ—¶æ•°ç»„
                    }
                }
                
                // å¦‚æœæ˜¯ç»“æ„åŒ–æ ¼å¼ï¼Œæ·»åŠ å°¾éƒ¨
                if (contentType === 'structured') {
                    const footer = getFileFooter(format);
                    if (footer) {
                        allBlobs.push(new Blob([footer], { type: mimeType }));
                    }
                }
                
                // æœ€ç»ˆåˆå¹¶
                progressText.textContent = 'æ­£åœ¨åˆå¹¶æ–‡ä»¶...';
                await new Promise(resolve => setTimeout(resolve, 100));
                
                const finalBlob = new Blob(allBlobs, { type: mimeType });
                
                // ä¸‹è½½
                downloadBlob(finalBlob, fileName, fileExt);
                
                const endTime = Date.now();
                progressContainer.style.display = 'none';
                showGenerationResult(finalBlob.size, fileName, fileExt, format, contentType, (endTime - startTime) / 1000, result);
                
                // æ¸…ç†
                allBlobs = null;
                
            } catch (e) {
                progressContainer.style.display = 'none';
                error.textContent = 'âŒ æ–‡ä»¶ç”Ÿæˆå¤±è´¥: ' + e.message + '\nå»ºè®®ç”Ÿæˆè¾ƒå°çš„æ–‡ä»¶æˆ–åˆ·æ–°é¡µé¢é‡è¯•';
                result.innerHTML = 'ç‚¹å‡»ç”ŸæˆæŒ‰é’®åˆ›å»ºæµ‹è¯•æ–‡ä»¶';
                console.error('æ–‡ä»¶ç”Ÿæˆé”™è¯¯:', e);
            }
        }

        // æ ¹æ®æ ¼å¼ç”Ÿæˆæ–‡ä»¶å†…å®¹
        function generateFileContentByFormat(sizeInBytes, format, contentType, isChunk = false) {
            // äºŒè¿›åˆ¶æ ¼å¼ï¼ˆPDF, PNG, JPGç­‰ï¼‰å¿…é¡»ç”Ÿæˆç»“æ„åŒ–å†…å®¹
            const binaryFormats = ['pdf', 'png', 'jpg', 'gif', 'bmp', 'zip', 'docx', 'xlsx', 'pptx'];
            
            if (binaryFormats.includes(format)) {
                // äºŒè¿›åˆ¶æ ¼å¼å¿½ç•¥contentTypeï¼Œå¼ºåˆ¶ä½¿ç”¨ç»“æ„åŒ–ç”Ÿæˆ
                return generateStructuredContent(format, sizeInBytes, isChunk);
            }
            
            // å¦‚æœæ˜¯ç»“æ„åŒ–å†…å®¹ï¼Œæ ¹æ®æ ¼å¼ç”Ÿæˆ
            if (contentType === 'structured' && !isChunk) {
                return generateStructuredContent(format, sizeInBytes, isChunk);
            }
            
            // å¦åˆ™ä½¿ç”¨åŸºç¡€å†…å®¹ç”Ÿæˆ
            return generateBaseContent(sizeInBytes, contentType);
        }
        
        // ç”Ÿæˆç»“æ„åŒ–å†…å®¹
        function generateStructuredContent(format, targetSize, isChunk = false) {
            let content = '';
            
            switch(format) {
                case 'json':
                    content = generateJSONContent(targetSize);
                    break;
                case 'csv':
                    content = generateCSVContent(targetSize);
                    break;
                case 'xml':
                    content = generateXMLContent(targetSize);
                    break;
                case 'html':
                    content = generateHTMLContent(targetSize);
                    break;
                case 'sql':
                    content = generateSQLContent(targetSize);
                    break;
                case 'log':
                    content = generateLogContent(targetSize);
                    break;
                case 'md':
                    content = generateMarkdownContent(targetSize);
                    break;
                case 'svg':
                    content = generateSVGContent(targetSize);
                    break;
                case 'bmp':
                    content = generateBMPContent(targetSize);
                    break;
                case 'png':
                    content = generatePNGContent(targetSize);
                    break;
                case 'jpg':
                    content = generateJPGContent(targetSize);
                    break;
                case 'gif':
                    content = generateGIFContent(targetSize);
                    break;
                case 'pdf':
                    content = generatePDFContent(targetSize);
                    break;
                case 'zip':
                    content = generateZIPContent(targetSize);
                    break;
                case 'docx':
                    content = generateDOCXContent(targetSize);
                    break;
                case 'xlsx':
                    content = generateXLSXContent(targetSize);
                    break;
                case 'pptx':
                    content = generatePPTXContent(targetSize);
                    break;
                default:
                    content = generateBaseContent(targetSize, 'random');
            }
            
            return content;
        }
        
        // ç”ŸæˆJSONå†…å®¹
        function generateJSONContent(targetSize) {
            let content = '{\n  "data": [\n';
            let currentSize = content.length;
            let index = 0;
            
            while (currentSize < targetSize - 100) {
                const item = `    {"id": ${index}, "name": "Test User ${index}", "email": "user${index}@test.com", "value": ${Math.random().toFixed(4)}},\n`;
                if (currentSize + item.length > targetSize - 50) break;
                content += item;
                currentSize += item.length;
                index++;
            }
            
            content = content.slice(0, -2) + '\n'; // ç§»é™¤æœ€åçš„é€—å·
            content += '  ]\n}';
            
            return content;
        }
        
        // ç”ŸæˆCSVå†…å®¹
        function generateCSVContent(targetSize) {
            let content = 'ID,Name,Email,Age,City,Score\n';
            let currentSize = content.length;
            let index = 1;
            
            const cities = ['Beijing', 'Shanghai', 'Guangzhou', 'Shenzhen', 'Hangzhou'];
            
            while (currentSize < targetSize - 100) {
                const row = `${index},User${index},user${index}@test.com,${20 + index % 50},${cities[index % cities.length]},${Math.floor(Math.random() * 100)}\n`;
                if (currentSize + row.length > targetSize) break;
                content += row;
                currentSize += row.length;
                index++;
            }
            
            return content;
        }
        
        // ç”ŸæˆXMLå†…å®¹
        function generateXMLContent(targetSize) {
            let content = '<?xml version="1.0" encoding="UTF-8"?>\n<root>\n';
            let currentSize = content.length;
            let index = 0;
            
            while (currentSize < targetSize - 200) {
                const item = `  <item id="${index}">\n    <name>Test Item ${index}</name>\n    <value>${Math.random().toFixed(4)}</value>\n  </item>\n`;
                if (currentSize + item.length > targetSize - 100) break;
                content += item;
                currentSize += item.length;
                index++;
            }
            
            content += '</root>';
            return content;
        }
        
        // ç”ŸæˆHTMLå†…å®¹
        function generateHTMLContent(targetSize) {
            let content = `<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Test HTML File</title>
</head>
<body>
    <h1>æµ‹è¯•HTMLæ–‡ä»¶</h1>
    <div class="content">
`;
            let currentSize = content.length;
            let index = 0;
            
            while (currentSize < targetSize - 200) {
                const item = `        <p>è¿™æ˜¯ç¬¬ ${index} æ®µæµ‹è¯•æ–‡æœ¬ã€‚Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p>\n`;
                if (currentSize + item.length > targetSize - 100) break;
                content += item;
                currentSize += item.length;
                index++;
            }
            
            content += '    </div>\n</body>\n</html>';
            return content;
        }
        
        // ç”ŸæˆSQLå†…å®¹
        function generateSQLContent(targetSize) {
            let content = '-- Test SQL Script\nCREATE TABLE IF NOT EXISTS test_users (\n  id INT PRIMARY KEY,\n  name VARCHAR(100),\n  email VARCHAR(100)\n);\n\n';
            let currentSize = content.length;
            let index = 1;
            
            while (currentSize < targetSize - 200) {
                const insert = `INSERT INTO test_users (id, name, email) VALUES (${index}, 'User ${index}', 'user${index}@test.com');\n`;
                if (currentSize + insert.length > targetSize - 50) break;
                content += insert;
                currentSize += insert.length;
                index++;
            }
            
            return content;
        }
        
        // ç”ŸæˆLOGå†…å®¹
        function generateLogContent(targetSize) {
            let content = '';
            let currentSize = 0;
            const levels = ['INFO', 'DEBUG', 'WARN', 'ERROR'];
            const messages = [
                'Application started successfully',
                'Database connection established',
                'User authentication failed',
                'Request processing completed',
                'Cache updated'
            ];
            
            while (currentSize < targetSize) {
                const timestamp = new Date(Date.now() - Math.random() * 86400000).toISOString();
                const level = levels[Math.floor(Math.random() * levels.length)];
                const message = messages[Math.floor(Math.random() * messages.length)];
                const line = `[${timestamp}] ${level}: ${message}\n`;
                
                if (currentSize + line.length > targetSize) break;
                content += line;
                currentSize += line.length;
            }
            
            return content;
        }
        
        // ç”ŸæˆMarkdownå†…å®¹
        function generateMarkdownContent(targetSize) {
            let content = '# æµ‹è¯•Markdownæ–‡æ¡£\n\n## ç®€ä»‹\n\nè¿™æ˜¯ä¸€ä¸ªè‡ªåŠ¨ç”Ÿæˆçš„æµ‹è¯•æ–‡æ¡£ã€‚\n\n';
            let currentSize = content.length;
            let section = 1;
            
            while (currentSize < targetSize - 200) {
                const item = `## ç« èŠ‚ ${section}\n\nè¿™æ˜¯ç¬¬ ${section} ä¸ªç« èŠ‚çš„å†…å®¹ã€‚åŒ…å«ä¸€äº›æµ‹è¯•æ–‡æœ¬ï¼š\n\n- åˆ—è¡¨é¡¹ 1\n- åˆ—è¡¨é¡¹ 2\n- åˆ—è¡¨é¡¹ 3\n\n`;
                if (currentSize + item.length > targetSize - 100) break;
                content += item;
                currentSize += item.length;
                section++;
            }
            
            return content;
        }
        
        // ç”ŸæˆSVGå†…å®¹
        function generateSVGContent(targetSize) {
            let content = '<svg xmlns="http://www.w3.org/2000/svg" width="1000" height="1000">\n';
            let currentSize = content.length;
            let index = 0;
            
            while (currentSize < targetSize - 200) {
                const x = Math.floor(Math.random() * 1000);
                const y = Math.floor(Math.random() * 1000);
                const r = Math.floor(Math.random() * 50) + 10;
                const color = `rgb(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`;
                const circle = `  <circle cx="${x}" cy="${y}" r="${r}" fill="${color}"/>\n`;
                
                if (currentSize + circle.length > targetSize - 50) break;
                content += circle;
                currentSize += circle.length;
                index++;
            }
            
            content += '</svg>';
            return content;
        }
        
        // ç”ŸæˆBMPå†…å®¹ï¼ˆç®€åŒ–ç‰ˆï¼Œç”Ÿæˆå•è‰²ä½å›¾å¤´éƒ¨+æ•°æ®ï¼‰
        function generateBMPContent(targetSize) {
            // BMPæ–‡ä»¶å¤´ï¼ˆ54å­—èŠ‚ï¼‰+ åƒç´ æ•°æ®
            const headerSize = 54;
            const pixelDataSize = targetSize - headerSize;
            
            // è®¡ç®—å›¾ç‰‡å°ºå¯¸ï¼ˆå‡è®¾24ä½è‰²æ·±ï¼‰
            const bytesPerPixel = 3;
            const width = Math.floor(Math.sqrt(pixelDataSize / bytesPerPixel));
            const height = width;
            const actualPixelDataSize = width * height * bytesPerPixel;
            
            // åˆ›å»ºBMPæ–‡ä»¶å¤´
            const buffer = new ArrayBuffer(headerSize + actualPixelDataSize);
            const view = new DataView(buffer);
            
            // BMæ ‡è¯†
            view.setUint8(0, 0x42); // 'B'
            view.setUint8(1, 0x4D); // 'M'
            
            // æ–‡ä»¶å¤§å°
            view.setUint32(2, headerSize + actualPixelDataSize, true);
            
            // ä¿ç•™å­—æ®µ
            view.setUint32(6, 0, true);
            
            // åƒç´ æ•°æ®åç§»
            view.setUint32(10, headerSize, true);
            
            // DIBå¤´å¤§å°
            view.setUint32(14, 40, true);
            
            // å›¾ç‰‡å®½åº¦å’Œé«˜åº¦
            view.setUint32(18, width, true);
            view.setUint32(22, height, true);
            
            // é¢œè‰²å¹³é¢æ•°
            view.setUint16(26, 1, true);
            
            // ä½æ·±åº¦
            view.setUint16(28, 24, true);
            
            // å‹ç¼©æ–¹å¼ï¼ˆ0=ä¸å‹ç¼©ï¼‰
            view.setUint32(30, 0, true);
            
            // åƒç´ æ•°æ®å¤§å°
            view.setUint32(34, actualPixelDataSize, true);
            
            // å¡«å……åƒç´ æ•°æ®ï¼ˆéšæœºé¢œè‰²ï¼‰
            const pixelArray = new Uint8Array(buffer, headerSize);
            for (let i = 0; i < actualPixelDataSize; i++) {
                pixelArray[i] = Math.floor(Math.random() * 256);
            }
            
            return buffer;
        }
        
        // ç”ŸæˆPNGå†…å®¹ï¼ˆç®€åŒ–ç‰ˆï¼Œ1x1åƒç´  + å¡«å……æ•°æ®ï¼‰
        function generatePNGContent(targetSize) {
            // PNGæœ€å°æ–‡ä»¶ï¼š8å­—èŠ‚ç­¾å + IHDR(25) + IDAT + IEND(12) â‰ˆ 70å­—èŠ‚
            const signature = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]); // PNGç­¾å
            
            // è®¡ç®—éœ€è¦çš„IDATæ•°æ®å¤§å°
            const minSize = 70;
            const idatDataSize = Math.max(100, targetSize - minSize);
            
            // åˆ›å»ºç¼“å†²åŒº
            const totalSize = signature.length + 25 + 12 + idatDataSize + 12;
            const buffer = new Uint8Array(totalSize);
            let offset = 0;
            
            // å†™å…¥PNGç­¾å
            buffer.set(signature, offset);
            offset += signature.length;
            
            // IHDRå—ï¼ˆå›¾åƒå¤´ï¼‰
            const ihdr = new Uint8Array([
                0, 0, 0, 13, // é•¿åº¦
                73, 72, 68, 82, // "IHDR"
                0, 0, 0, 1, // å®½åº¦ = 1
                0, 0, 0, 1, // é«˜åº¦ = 1
                8, // ä½æ·±åº¦
                2, // é¢œè‰²ç±»å‹ï¼ˆRGBï¼‰
                0, 0, 0, // å‹ç¼©ã€è¿‡æ»¤ã€äº¤é”™
                0, 0, 0, 0  // CRCï¼ˆç®€åŒ–ä¸º0ï¼‰
            ]);
            buffer.set(ihdr, offset);
            offset += ihdr.length;
            
            // IDATå—ï¼ˆå›¾åƒæ•°æ®ï¼‰
            const idatHeader = new Uint8Array(8);
            const view = new DataView(idatHeader.buffer);
            view.setUint32(0, idatDataSize, false); // é•¿åº¦
            idatHeader[4] = 73; // 'I'
            idatHeader[5] = 68; // 'D'
            idatHeader[6] = 65; // 'A'
            idatHeader[7] = 84; // 'T'
            buffer.set(idatHeader, offset);
            offset += idatHeader.length;
            
            // å¡«å……éšæœºæ•°æ®
            for (let i = 0; i < idatDataSize; i++) {
                buffer[offset++] = Math.floor(Math.random() * 256);
            }
            
            // IDAT CRCï¼ˆç®€åŒ–ä¸º0ï¼‰
            buffer[offset++] = 0;
            buffer[offset++] = 0;
            buffer[offset++] = 0;
            buffer[offset++] = 0;
            
            // IENDå—
            const iend = new Uint8Array([
                0, 0, 0, 0, // é•¿åº¦
                73, 69, 78, 68, // "IEND"
                174, 66, 96, 130 // CRC
            ]);
            buffer.set(iend, offset);
            
            return buffer.buffer;
        }
        
        // ç”ŸæˆJPGå†…å®¹ï¼ˆJFIFæ ¼å¼ï¼‰
        function generateJPGContent(targetSize) {
            // JPGæœ€å°ç»“æ„ï¼šSOI(2) + APP0(18) + ... + EOI(2)
            const minSize = 200;
            const dataSize = Math.max(minSize, targetSize);
            
            const buffer = new Uint8Array(dataSize);
            let offset = 0;
            
            // SOI (Start of Image)
            buffer[offset++] = 0xFF;
            buffer[offset++] = 0xD8;
            
            // APP0 (JFIFæ ‡è¯†)
            buffer[offset++] = 0xFF;
            buffer[offset++] = 0xE0;
            buffer[offset++] = 0x00;
            buffer[offset++] = 0x10; // é•¿åº¦
            buffer[offset++] = 0x4A; // 'J'
            buffer[offset++] = 0x46; // 'F'
            buffer[offset++] = 0x49; // 'I'
            buffer[offset++] = 0x46; // 'F'
            buffer[offset++] = 0x00; // ç»“æŸç¬¦
            buffer[offset++] = 0x01; // ç‰ˆæœ¬
            buffer[offset++] = 0x01;
            buffer[offset++] = 0x00; // å•ä½
            buffer[offset++] = 0x00;
            buffer[offset++] = 0x01; // Xå¯†åº¦
            buffer[offset++] = 0x00;
            buffer[offset++] = 0x01; // Yå¯†åº¦
            buffer[offset++] = 0x00; // ç¼©ç•¥å›¾
            buffer[offset++] = 0x00;
            
            // å¡«å……æ•°æ®ï¼ˆæ¨¡æ‹Ÿæ‰«ææ•°æ®ï¼‰
            while (offset < dataSize - 2) {
                buffer[offset++] = Math.floor(Math.random() * 256);
            }
            
            // EOI (End of Image)
            buffer[dataSize - 2] = 0xFF;
            buffer[dataSize - 1] = 0xD9;
            
            return buffer.buffer;
        }
        
        // ç”ŸæˆGIFå†…å®¹ï¼ˆGIF89aæ ¼å¼ï¼‰
        function generateGIFContent(targetSize) {
            const minSize = 100;
            const dataSize = Math.max(minSize, targetSize);
            
            const buffer = new Uint8Array(dataSize);
            let offset = 0;
            
            // GIFå¤´éƒ¨
            const header = [71, 73, 70, 56, 57, 97]; // "GIF89a"
            buffer.set(header, offset);
            offset += header.length;
            
            // é€»è¾‘å±å¹•å®½åº¦/é«˜åº¦
            buffer[offset++] = 1; // å®½åº¦ä½å­—èŠ‚
            buffer[offset++] = 0; // å®½åº¦é«˜å­—èŠ‚
            buffer[offset++] = 1; // é«˜åº¦ä½å­—èŠ‚
            buffer[offset++] = 0; // é«˜åº¦é«˜å­—èŠ‚
            
            // å…¨å±€é¢œè‰²è¡¨
            buffer[offset++] = 0x80; // GCTæ ‡å¿—
            buffer[offset++] = 0x00; // èƒŒæ™¯è‰²
            buffer[offset++] = 0x00; // åƒç´ æ¯”ä¾‹
            
            // é¢œè‰²è¡¨ï¼ˆ2è‰²ï¼‰
            buffer[offset++] = 0; buffer[offset++] = 0; buffer[offset++] = 0; // é»‘
            buffer[offset++] = 255; buffer[offset++] = 255; buffer[offset++] = 255; // ç™½
            
            // å¡«å……æ•°æ®
            while (offset < dataSize - 1) {
                buffer[offset++] = Math.floor(Math.random() * 256);
            }
            
            // GIFç»“æŸç¬¦
            buffer[dataSize - 1] = 0x3B;
            
            return buffer.buffer;
        }
        
        // ç”ŸæˆPDFå†…å®¹ï¼ˆä¿®å¤ç‰ˆï¼Œå®Œæ•´çš„PDFç»“æ„ï¼‰
        function generatePDFContent(targetSize) {
            // æ„å»ºPDFå¯¹è±¡
            const objects = [];
            let currentOffset = 0;
            
            // PDFå¤´éƒ¨
            const header = '%PDF-1.4\n';
            currentOffset = header.length;
            
            // å¯¹è±¡1ï¼šç›®å½•
            const obj1Start = currentOffset;
            const obj1 = '1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj\n';
            objects.push({ id: 1, offset: obj1Start });
            currentOffset += obj1.length;
            
            // å¯¹è±¡2ï¼šé¡µé¢æ ‘
            const obj2Start = currentOffset;
            const obj2 = '2 0 obj\n<< /Type /Pages /Kids [3 0 R] /Count 1 >>\nendobj\n';
            objects.push({ id: 2, offset: obj2Start });
            currentOffset += obj2.length;
            
            // å¯¹è±¡3ï¼šé¡µé¢
            const obj3Start = currentOffset;
            const obj3 = '3 0 obj\n<< /Type /Page /Parent 2 0 R /Resources << /Font << /F1 4 0 R >> >> /MediaBox [0 0 612 792] /Contents 5 0 R >>\nendobj\n';
            objects.push({ id: 3, offset: obj3Start });
            currentOffset += obj3.length;
            
            // å¯¹è±¡4ï¼šå­—ä½“
            const obj4Start = currentOffset;
            const obj4 = '4 0 obj\n<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>\nendobj\n';
            objects.push({ id: 4, offset: obj4Start });
            currentOffset += obj4.length;
            
            // å¯¹è±¡5ï¼šå†…å®¹æµ
            // è®¡ç®—éœ€è¦çš„æ–‡æœ¬é‡ä»¥è¾¾åˆ°ç›®æ ‡å¤§å°
            const currentSize = currentOffset + 200; // é¢„ç•™ç©ºé—´
            const remainingSize = Math.max(100, targetSize - currentSize);
            
            let streamContent = 'BT\n/F1 12 Tf\n50 720 Td\n15 TL\n';
            
            // ç”Ÿæˆæ–‡æœ¬è¡Œ
            let textSize = 0;
            let lineNum = 1;
            while (textSize < remainingSize - 200) {
                const line = `(This is test line ${lineNum} - Generated by Test File Generator) Tj T*\n`;
                if (textSize + line.length > remainingSize - 100) break;
                streamContent += line;
                textSize += line.length;
                lineNum++;
                
                // æ¯50è¡Œæ·»åŠ ä¸€ä¸ªæ¢é¡µæ ‡è®°ï¼ˆå¦‚æœéœ€è¦ï¼‰
                if (lineNum % 50 === 0 && textSize < remainingSize - 300) {
                    streamContent += 'ET\n';
                    streamContent += 'BT\n/F1 12 Tf\n50 720 Td\n15 TL\n';
                }
            }
            streamContent += 'ET\n';
            
            const obj5Start = currentOffset;
            const obj5 = `5 0 obj\n<< /Length ${streamContent.length} >>\nstream\n${streamContent}endstream\nendobj\n`;
            objects.push({ id: 5, offset: obj5Start });
            currentOffset += obj5.length;
            
            // æ„å»ºå®Œæ•´PDF
            let pdfContent = header + obj1 + obj2 + obj3 + obj4 + obj5;
            
            // äº¤å‰å¼•ç”¨è¡¨
            const xrefOffset = pdfContent.length;
            let xref = 'xref\n0 6\n';
            xref += '0000000000 65535 f \n';
            objects.forEach(obj => {
                xref += String(obj.offset).padStart(10, '0') + ' 00000 n \n';
            });
            
            // å°¾éƒ¨
            const trailer = `trailer\n<< /Size 6 /Root 1 0 R >>\nstartxref\n${xrefOffset}\n%%EOF`;
            
            pdfContent += xref + trailer;
            
            return pdfContent;
        }
        
        // ç”ŸæˆZIPå†…å®¹ï¼ˆä¿®å¤ç‰ˆï¼Œè®¡ç®—æ­£ç¡®çš„CRC32ï¼‰
        function generateZIPContent(targetSize) {
            const fileName = 'readme.txt';
            const fileNameBytes = new TextEncoder().encode(fileName);
            
            // ç”Ÿæˆæ–‡ä»¶å†…å®¹
            let fileContent = '=== Test ZIP Archive ===\n\n';
            fileContent += 'This is a test ZIP file generated by Test File Generator.\n\n';
            fileContent += 'Content:\n';
            
            const baseText = 'Line {num}: This is test data for ZIP archive generation. The quick brown fox jumps over the lazy dog.\n';
            let lineNum = 1;
            while (fileContent.length < targetSize - 200) {
                const line = baseText.replace('{num}', lineNum);
                if (fileContent.length + line.length > targetSize - 150) break;
                fileContent += line;
                lineNum++;
            }
            
            const fileContentBytes = new TextEncoder().encode(fileContent);
            
            // è®¡ç®—CRC32
            const crc32 = calculateCRC32(fileContentBytes);
            
            // DOSæ—¶é—´å’Œæ—¥æœŸï¼ˆ2024å¹´1æœˆ1æ—¥ 12:00:00ï¼‰
            const dosTime = 0x6000; // 12:00:00
            const dosDate = 0x5821; // 2024-01-01
            
            // è®¡ç®—æ€»å¤§å°
            const localHeaderSize = 30 + fileNameBytes.length;
            const centralDirSize = 46 + fileNameBytes.length;
            const endRecordSize = 22;
            const totalSize = localHeaderSize + fileContentBytes.length + centralDirSize + endRecordSize;
            
            const buffer = new Uint8Array(totalSize);
            const view = new DataView(buffer.buffer);
            let offset = 0;
            
            // ========== æœ¬åœ°æ–‡ä»¶å¤´ ==========
            view.setUint32(offset, 0x04034b50, true); offset += 4; // PKç­¾å
            view.setUint16(offset, 20, true); offset += 2; // ç‰ˆæœ¬
            view.setUint16(offset, 0, true); offset += 2; // é€šç”¨æ ‡å¿—
            view.setUint16(offset, 0, true); offset += 2; // å‹ç¼©æ–¹æ³•ï¼ˆ0=ä¸å‹ç¼©ï¼‰
            view.setUint16(offset, dosTime, true); offset += 2; // ä¿®æ”¹æ—¶é—´
            view.setUint16(offset, dosDate, true); offset += 2; // ä¿®æ”¹æ—¥æœŸ
            view.setUint32(offset, crc32, true); offset += 4; // CRC-32
            view.setUint32(offset, fileContentBytes.length, true); offset += 4; // å‹ç¼©å¤§å°
            view.setUint32(offset, fileContentBytes.length, true); offset += 4; // æœªå‹ç¼©å¤§å°
            view.setUint16(offset, fileNameBytes.length, true); offset += 2; // æ–‡ä»¶åé•¿åº¦
            view.setUint16(offset, 0, true); offset += 2; // é¢å¤–å­—æ®µé•¿åº¦
            buffer.set(fileNameBytes, offset); offset += fileNameBytes.length;
            
            // æ–‡ä»¶æ•°æ®
            const fileDataStart = offset;
            buffer.set(fileContentBytes, offset);
            offset += fileContentBytes.length;
            
            // ========== ä¸­å¤®ç›®å½•è®°å½• ==========
            const centralDirStart = offset;
            view.setUint32(offset, 0x02014b50, true); offset += 4; // PKç­¾å
            view.setUint16(offset, 20, true); offset += 2; // åˆ›å»ºç‰ˆæœ¬
            view.setUint16(offset, 20, true); offset += 2; // éœ€è¦ç‰ˆæœ¬
            view.setUint16(offset, 0, true); offset += 2; // é€šç”¨æ ‡å¿—
            view.setUint16(offset, 0, true); offset += 2; // å‹ç¼©æ–¹æ³•
            view.setUint16(offset, dosTime, true); offset += 2; // ä¿®æ”¹æ—¶é—´
            view.setUint16(offset, dosDate, true); offset += 2; // ä¿®æ”¹æ—¥æœŸ
            view.setUint32(offset, crc32, true); offset += 4; // CRC-32
            view.setUint32(offset, fileContentBytes.length, true); offset += 4; // å‹ç¼©å¤§å°
            view.setUint32(offset, fileContentBytes.length, true); offset += 4; // æœªå‹ç¼©å¤§å°
            view.setUint16(offset, fileNameBytes.length, true); offset += 2; // æ–‡ä»¶åé•¿åº¦
            view.setUint16(offset, 0, true); offset += 2; // é¢å¤–å­—æ®µé•¿åº¦
            view.setUint16(offset, 0, true); offset += 2; // æ–‡ä»¶æ³¨é‡Šé•¿åº¦
            view.setUint16(offset, 0, true); offset += 2; // ç£ç›˜å·
            view.setUint16(offset, 0, true); offset += 2; // å†…éƒ¨æ–‡ä»¶å±æ€§
            view.setUint32(offset, 0, true); offset += 4; // å¤–éƒ¨æ–‡ä»¶å±æ€§
            view.setUint32(offset, 0, true); offset += 4; // æœ¬åœ°å¤´ç›¸å¯¹åç§»
            buffer.set(fileNameBytes, offset); offset += fileNameBytes.length;
            
            // ========== ä¸­å¤®ç›®å½•ç»“æŸè®°å½• ==========
            view.setUint32(offset, 0x06054b50, true); offset += 4; // PKç­¾å
            view.setUint16(offset, 0, true); offset += 2; // å½“å‰ç£ç›˜å·
            view.setUint16(offset, 0, true); offset += 2; // ä¸­å¤®ç›®å½•å¼€å§‹ç£ç›˜å·
            view.setUint16(offset, 1, true); offset += 2; // æœ¬ç£ç›˜ä¸Šçš„è®°å½•æ•°
            view.setUint16(offset, 1, true); offset += 2; // æ€»è®°å½•æ•°
            view.setUint32(offset, centralDirSize, true); offset += 4; // ä¸­å¤®ç›®å½•å¤§å°
            view.setUint32(offset, centralDirStart, true); offset += 4; // ä¸­å¤®ç›®å½•åç§»
            view.setUint16(offset, 0, true); offset += 2; // æ³¨é‡Šé•¿åº¦
            
            return buffer.buffer;
        }
        
        // CRC32è®¡ç®—å‡½æ•°
        function calculateCRC32(bytes) {
            const crcTable = new Uint32Array(256);
            for (let i = 0; i < 256; i++) {
                let c = i;
                for (let j = 0; j < 8; j++) {
                    c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
                }
                crcTable[i] = c;
            }
            
            let crc = 0xFFFFFFFF;
            for (let i = 0; i < bytes.length; i++) {
                crc = crcTable[(crc ^ bytes[i]) & 0xFF] ^ (crc >>> 8);
            }
            return (crc ^ 0xFFFFFFFF) >>> 0;
        }
        
        // ç”ŸæˆDOCXå†…å®¹ï¼ˆçœŸå®çš„Office Open XMLæ ¼å¼ï¼‰
        function generateDOCXContent(targetSize) {
            // åˆ›å»ºå¿…éœ€çš„XMLæ–‡ä»¶
            const files = [];
            
            // 1. [Content_Types].xml
            const contentTypes = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="xml" ContentType="application/xml"/>
  <Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
</Types>`;
            files.push({ name: '[Content_Types].xml', content: contentTypes });
            
            // 2. _rels/.rels
            const rels = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
</Relationships>`;
            files.push({ name: '_rels/.rels', content: rels });
            
            // 3. word/document.xmlï¼ˆåŒ…å«å®é™…å†…å®¹ï¼‰
            let documentXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
  <w:body>
`;
            
            // è®¡ç®—éœ€è¦å¤šå°‘æ®µè½æ¥è¾¾åˆ°ç›®æ ‡å¤§å°
            const baseSize = contentTypes.length + rels.length + documentXml.length + 100;
            const remainingSize = Math.max(100, targetSize - baseSize);
            let paraNum = 1;
            let contentSize = 0;
            
            while (contentSize < remainingSize - 200) {
                const para = `    <w:p><w:r><w:t>è¿™æ˜¯æµ‹è¯•Wordæ–‡æ¡£çš„ç¬¬ ${paraNum} æ®µã€‚ç”±æµ‹è¯•æ–‡ä»¶ç”Ÿæˆå™¨åˆ›å»ºã€‚This is paragraph ${paraNum} in the test Word document. Generated by Test File Generator. Lorem ipsum dolor sit amet.</w:t></w:r></w:p>\n`;
                if (contentSize + para.length > remainingSize - 100) break;
                documentXml += para;
                contentSize += para.length;
                paraNum++;
            }
            
            documentXml += `  </w:body>
</w:document>`;
            files.push({ name: 'word/document.xml', content: documentXml });
            
            return createMultiFileZIP(files);
        }
        
        // ç”ŸæˆXLSXå†…å®¹ï¼ˆçœŸå®çš„Excelæ ¼å¼ï¼‰
        function generateXLSXContent(targetSize) {
            const files = [];
            
            // 1. [Content_Types].xml
            const contentTypes = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="xml" ContentType="application/xml"/>
  <Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"/>
  <Override PartName="/xl/worksheets/sheet1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml"/>
  <Override PartName="/xl/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml"/>
  <Override PartName="/xl/sharedStrings.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml"/>
</Types>`;
            files.push({ name: '[Content_Types].xml', content: contentTypes });
            
            // 2. _rels/.rels
            const rels = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/>
</Relationships>`;
            files.push({ name: '_rels/.rels', content: rels });
            
            // 3. xl/workbook.xml
            const workbook = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">
  <sheets>
    <sheet name="Sheet1" sheetId="1" r:id="rId1"/>
  </sheets>
</workbook>`;
            files.push({ name: 'xl/workbook.xml', content: workbook });
            
            // 4. xl/_rels/workbook.xml.rels
            const workbookRels = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet1.xml"/>
  <Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/>
  <Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings" Target="sharedStrings.xml"/>
</Relationships>`;
            files.push({ name: 'xl/_rels/workbook.xml.rels', content: workbookRels });
            
            // 5. xl/styles.xml
            const styles = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"/>`;
            files.push({ name: 'xl/styles.xml', content: styles });
            
            // 6. xl/sharedStrings.xmlï¼ˆåŒ…å«æ‰€æœ‰æ–‡æœ¬ï¼‰
            let sharedStrings = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="1" uniqueCount="1">
  <si><t>æµ‹è¯•æ•°æ® Test Data</t></si>
</sst>`;
            files.push({ name: 'xl/sharedStrings.xml', content: sharedStrings });
            
            // 7. xl/worksheets/sheet1.xmlï¼ˆå·¥ä½œè¡¨æ•°æ®ï¼‰
            let worksheet = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main">
  <sheetData>
`;
            
            // è®¡ç®—éœ€è¦å¤šå°‘è¡Œæ¥è¾¾åˆ°ç›®æ ‡å¤§å°
            const baseSize = contentTypes.length + rels.length + workbook.length + workbookRels.length + styles.length + sharedStrings.length + worksheet.length + 200;
            const remainingSize = Math.max(100, targetSize - baseSize);
            let rowNum = 1;
            let contentSize = 0;
            
            while (contentSize < remainingSize - 300) {
                const row = `    <row r="${rowNum}"><c r="A${rowNum}" t="s"><v>0</v></c><c r="B${rowNum}"><v>${rowNum}</v></c><c r="C${rowNum}"><v>${rowNum * 100}</v></c></row>\n`;
                if (contentSize + row.length > remainingSize - 100) break;
                worksheet += row;
                contentSize += row.length;
                rowNum++;
            }
            
            worksheet += `  </sheetData>
</worksheet>`;
            files.push({ name: 'xl/worksheets/sheet1.xml', content: worksheet });
            
            return createMultiFileZIP(files);
        }
        
        // ç”ŸæˆPPTXå†…å®¹ï¼ˆçœŸå®çš„PowerPointæ ¼å¼ï¼‰
        function generatePPTXContent(targetSize) {
            const files = [];
            
            // 1. [Content_Types].xml
            const contentTypes = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="xml" ContentType="application/xml"/>
  <Override PartName="/ppt/presentation.xml" ContentType="application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml"/>
  <Override PartName="/ppt/slides/slide1.xml" ContentType="application/vnd.openxmlformats-officedocument.presentationml.slide+xml"/>
  <Override PartName="/ppt/slideLayouts/slideLayout1.xml" ContentType="application/vnd.openxmlformats-officedocument.presentationml.slideLayout+xml"/>
  <Override PartName="/ppt/slideMasters/slideMaster1.xml" ContentType="application/vnd.openxmlformats-officedocument.presentationml.slideMaster+xml"/>
</Types>`;
            files.push({ name: '[Content_Types].xml', content: contentTypes });
            
            // 2. _rels/.rels
            const rels = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="ppt/presentation.xml"/>
</Relationships>`;
            files.push({ name: '_rels/.rels', content: rels });
            
            // 3. ppt/presentation.xml
            const presentation = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<p:presentation xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">
  <p:sldIdLst>
    <p:sldId id="256" r:id="rId1"/>
  </p:sldIdLst>
  <p:sldSz cx="9144000" cy="6858000"/>
</p:presentation>`;
            files.push({ name: 'ppt/presentation.xml', content: presentation });
            
            // 4. ppt/_rels/presentation.xml.rels
            const presentationRels = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slide" Target="slides/slide1.xml"/>
  <Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideMaster" Target="slideMasters/slideMaster1.xml"/>
</Relationships>`;
            files.push({ name: 'ppt/_rels/presentation.xml.rels', content: presentationRels });
            
            // 5. ppt/slides/slide1.xmlï¼ˆå¹»ç¯ç‰‡å†…å®¹ï¼‰
            let slide = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<p:sld xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main" xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">
  <p:cSld>
    <p:spTree>
      <p:nvGrpSpPr><p:cNvPr id="1" name=""/><p:cNvGrpSpPr/><p:nvPr/></p:nvGrpSpPr>
      <p:grpSpPr/>
      <p:sp>
        <p:nvSpPr><p:cNvPr id="2" name="Title"/><p:cNvSpPr><a:spLocks noGrp="1"/></p:cNvSpPr><p:nvPr/></p:nvSpPr>
        <p:spPr/>
        <p:txBody>
          <a:bodyPr/>
          <a:lstStyle/>
          <a:p>
            <a:r><a:t>æµ‹è¯•æ¼”ç¤ºæ–‡ç¨¿ Test Presentation</a:t></a:r>
          </a:p>
`;
            
            // æ·»åŠ æ›´å¤šæ®µè½ä»¥è¾¾åˆ°ç›®æ ‡å¤§å°
            const baseSize = contentTypes.length + rels.length + presentation.length + presentationRels.length + slide.length + 300;
            const remainingSize = Math.max(100, targetSize - baseSize);
            let paraNum = 1;
            let contentSize = 0;
            
            while (contentSize < remainingSize - 500) {
                const para = `          <a:p><a:r><a:t>è¿™æ˜¯å¹»ç¯ç‰‡å†…å®¹ç¬¬ ${paraNum} è¡Œã€‚Slide content line ${paraNum}. Generated by Test File Generator.</a:t></a:r></a:p>\n`;
                if (contentSize + para.length > remainingSize - 200) break;
                slide += para;
                contentSize += para.length;
                paraNum++;
            }
            
            slide += `        </p:txBody>
      </p:sp>
    </p:spTree>
  </p:cSld>
</p:sld>`;
            files.push({ name: 'ppt/slides/slide1.xml', content: slide });
            
            // 6. ppt/slides/_rels/slide1.xml.rels
            const slideRels = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideLayout" Target="../slideLayouts/slideLayout1.xml"/>
</Relationships>`;
            files.push({ name: 'ppt/slides/_rels/slide1.xml.rels', content: slideRels });
            
            // 7. ppt/slideLayouts/slideLayout1.xml
            const slideLayout = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<p:sldLayout xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">
  <p:cSld><p:spTree><p:nvGrpSpPr><p:cNvPr id="1" name=""/><p:cNvGrpSpPr/><p:nvPr/></p:nvGrpSpPr><p:grpSpPr/></p:spTree></p:cSld>
</p:sldLayout>`;
            files.push({ name: 'ppt/slideLayouts/slideLayout1.xml', content: slideLayout });
            
            // 8. ppt/slideLayouts/_rels/slideLayout1.xml.rels
            const slideLayoutRels = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideMaster" Target="../slideMasters/slideMaster1.xml"/>
</Relationships>`;
            files.push({ name: 'ppt/slideLayouts/_rels/slideLayout1.xml.rels', content: slideLayoutRels });
            
            // 9. ppt/slideMasters/slideMaster1.xml
            const slideMaster = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<p:sldMaster xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main">
  <p:cSld><p:spTree><p:nvGrpSpPr><p:cNvPr id="1" name=""/><p:cNvGrpSpPr/><p:nvPr/></p:nvGrpSpPr><p:grpSpPr/></p:spTree></p:cSld>
  <p:sldLayoutIdLst><p:sldLayoutId id="2147483649" r:id="rId1" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"/></p:sldLayoutIdLst>
</p:sldMaster>`;
            files.push({ name: 'ppt/slideMasters/slideMaster1.xml', content: slideMaster });
            
            return createMultiFileZIP(files);
        }
        
        // åˆ›å»ºåŒ…å«å¤šä¸ªæ–‡ä»¶çš„ZIPåŒ…ï¼ˆç”¨äºOfficeæ–‡æ¡£ï¼‰
        function createMultiFileZIP(files) {
            // è®¡ç®—æ€»å¤§å°
            let totalSize = 0;
            const fileData = [];
            
            // å‡†å¤‡æ¯ä¸ªæ–‡ä»¶çš„æ•°æ®
            for (const file of files) {
                const nameBytes = new TextEncoder().encode(file.name);
                const contentBytes = new TextEncoder().encode(file.content);
                const crc32 = calculateCRC32(contentBytes);
                
                fileData.push({
                    name: file.name,
                    nameBytes: nameBytes,
                    contentBytes: contentBytes,
                    crc32: crc32
                });
                
                // æœ¬åœ°æ–‡ä»¶å¤´(30) + æ–‡ä»¶åé•¿åº¦ + æ–‡ä»¶å†…å®¹é•¿åº¦
                totalSize += 30 + nameBytes.length + contentBytes.length;
                // ä¸­å¤®ç›®å½•è®°å½•(46) + æ–‡ä»¶åé•¿åº¦
                totalSize += 46 + nameBytes.length;
            }
            
            // ç»“æŸè®°å½•(22)
            totalSize += 22;
            
            const buffer = new Uint8Array(totalSize);
            const view = new DataView(buffer.buffer);
            let offset = 0;
            const localHeaderOffsets = [];
            
            const dosTime = 0x6000;
            const dosDate = 0x5821;
            
            // å†™å…¥æ‰€æœ‰æœ¬åœ°æ–‡ä»¶å¤´å’Œæ–‡ä»¶æ•°æ®
            for (const file of fileData) {
                localHeaderOffsets.push(offset);
                
                // æœ¬åœ°æ–‡ä»¶å¤´ç­¾å
                view.setUint32(offset, 0x04034b50, true); offset += 4;
                // ç‰ˆæœ¬
                view.setUint16(offset, 20, true); offset += 2;
                // é€šç”¨ä½æ ‡å¿—
                view.setUint16(offset, 0, true); offset += 2;
                // å‹ç¼©æ–¹æ³•ï¼ˆ0=æ— å‹ç¼©ï¼‰
                view.setUint16(offset, 0, true); offset += 2;
                // ä¿®æ”¹æ—¶é—´
                view.setUint16(offset, dosTime, true); offset += 2;
                // ä¿®æ”¹æ—¥æœŸ
                view.setUint16(offset, dosDate, true); offset += 2;
                // CRC32
                view.setUint32(offset, file.crc32, true); offset += 4;
                // å‹ç¼©åå¤§å°
                view.setUint32(offset, file.contentBytes.length, true); offset += 4;
                // æœªå‹ç¼©å¤§å°
                view.setUint32(offset, file.contentBytes.length, true); offset += 4;
                // æ–‡ä»¶åé•¿åº¦
                view.setUint16(offset, file.nameBytes.length, true); offset += 2;
                // æ‰©å±•å­—æ®µé•¿åº¦
                view.setUint16(offset, 0, true); offset += 2;
                // æ–‡ä»¶å
                buffer.set(file.nameBytes, offset); offset += file.nameBytes.length;
                // æ–‡ä»¶æ•°æ®
                buffer.set(file.contentBytes, offset); offset += file.contentBytes.length;
            }
            
            // ä¸­å¤®ç›®å½•å¼€å§‹ä½ç½®
            const centralDirStart = offset;
            
            // å†™å…¥æ‰€æœ‰ä¸­å¤®ç›®å½•è®°å½•
            for (let i = 0; i < fileData.length; i++) {
                const file = fileData[i];
                
                // ä¸­å¤®ç›®å½•æ–‡ä»¶å¤´ç­¾å
                view.setUint32(offset, 0x02014b50, true); offset += 4;
                // ç‰ˆæœ¬
                view.setUint16(offset, 20, true); offset += 2;
                // éœ€è¦çš„ç‰ˆæœ¬
                view.setUint16(offset, 20, true); offset += 2;
                // é€šç”¨ä½æ ‡å¿—
                view.setUint16(offset, 0, true); offset += 2;
                // å‹ç¼©æ–¹æ³•
                view.setUint16(offset, 0, true); offset += 2;
                // ä¿®æ”¹æ—¶é—´
                view.setUint16(offset, dosTime, true); offset += 2;
                // ä¿®æ”¹æ—¥æœŸ
                view.setUint16(offset, dosDate, true); offset += 2;
                // CRC32
                view.setUint32(offset, file.crc32, true); offset += 4;
                // å‹ç¼©åå¤§å°
                view.setUint32(offset, file.contentBytes.length, true); offset += 4;
                // æœªå‹ç¼©å¤§å°
                view.setUint32(offset, file.contentBytes.length, true); offset += 4;
                // æ–‡ä»¶åé•¿åº¦
                view.setUint16(offset, file.nameBytes.length, true); offset += 2;
                // æ‰©å±•å­—æ®µé•¿åº¦
                view.setUint16(offset, 0, true); offset += 2;
                // æ–‡ä»¶æ³¨é‡Šé•¿åº¦
                view.setUint16(offset, 0, true); offset += 2;
                // ç£ç›˜å·
                view.setUint16(offset, 0, true); offset += 2;
                // å†…éƒ¨æ–‡ä»¶å±æ€§
                view.setUint16(offset, 0, true); offset += 2;
                // å¤–éƒ¨æ–‡ä»¶å±æ€§
                view.setUint32(offset, 0, true); offset += 4;
                // æœ¬åœ°æ–‡ä»¶å¤´åç§»
                view.setUint32(offset, localHeaderOffsets[i], true); offset += 4;
                // æ–‡ä»¶å
                buffer.set(file.nameBytes, offset); offset += file.nameBytes.length;
            }
            
            // ä¸­å¤®ç›®å½•å¤§å°
            const centralDirSize = offset - centralDirStart;
            
            // å†™å…¥ç»“æŸè®°å½•
            // ç»“æŸè®°å½•ç­¾å
            view.setUint32(offset, 0x06054b50, true); offset += 4;
            // å½“å‰ç£ç›˜å·
            view.setUint16(offset, 0, true); offset += 2;
            // ä¸­å¤®ç›®å½•å¼€å§‹ç£ç›˜å·
            view.setUint16(offset, 0, true); offset += 2;
            // å½“å‰ç£ç›˜ä¸Šçš„ä¸­å¤®ç›®å½•è®°å½•æ•°
            view.setUint16(offset, fileData.length, true); offset += 2;
            // ä¸­å¤®ç›®å½•è®°å½•æ€»æ•°
            view.setUint16(offset, fileData.length, true); offset += 2;
            // ä¸­å¤®ç›®å½•å¤§å°
            view.setUint32(offset, centralDirSize, true); offset += 4;
            // ä¸­å¤®ç›®å½•åç§»
            view.setUint32(offset, centralDirStart, true); offset += 4;
            // ZIPæ–‡ä»¶æ³¨é‡Šé•¿åº¦
            view.setUint16(offset, 0, true); offset += 2;
            
            return buffer.buffer;
        }
        
        // ç”Ÿæˆè‡ªå®šä¹‰å†…å®¹çš„ZIPï¼ˆç”¨äºOfficeæ–‡æ¡£ï¼‰
        function generateCustomZIP(fileName, baseContent, targetSize) {
            const fileNameBytes = new TextEncoder().encode(fileName);
            
            // æ‰©å±•å†…å®¹ä»¥è¾¾åˆ°ç›®æ ‡å¤§å°
            let fileContent = baseContent;
            let lineNum = 1;
            while (fileContent.length < targetSize - 200) {
                const line = `Line ${lineNum}: Additional test data for file size padding. Lorem ipsum dolor sit amet.\n`;
                if (fileContent.length + line.length > targetSize - 150) break;
                fileContent += line;
                lineNum++;
            }
            
            const fileContentBytes = new TextEncoder().encode(fileContent);
            const crc32 = calculateCRC32(fileContentBytes);
            
            const dosTime = 0x6000;
            const dosDate = 0x5821;
            
            const localHeaderSize = 30 + fileNameBytes.length;
            const centralDirSize = 46 + fileNameBytes.length;
            const totalSize = localHeaderSize + fileContentBytes.length + centralDirSize + 22;
            
            const buffer = new Uint8Array(totalSize);
            const view = new DataView(buffer.buffer);
            let offset = 0;
            
            // æœ¬åœ°æ–‡ä»¶å¤´
            view.setUint32(offset, 0x04034b50, true); offset += 4;
            view.setUint16(offset, 20, true); offset += 2;
            view.setUint16(offset, 0, true); offset += 2;
            view.setUint16(offset, 0, true); offset += 2;
            view.setUint16(offset, dosTime, true); offset += 2;
            view.setUint16(offset, dosDate, true); offset += 2;
            view.setUint32(offset, crc32, true); offset += 4;
            view.setUint32(offset, fileContentBytes.length, true); offset += 4;
            view.setUint32(offset, fileContentBytes.length, true); offset += 4;
            view.setUint16(offset, fileNameBytes.length, true); offset += 2;
            view.setUint16(offset, 0, true); offset += 2;
            buffer.set(fileNameBytes, offset); offset += fileNameBytes.length;
            
            // æ–‡ä»¶æ•°æ®
            buffer.set(fileContentBytes, offset);
            offset += fileContentBytes.length;
            
            // ä¸­å¤®ç›®å½•
            const centralDirStart = offset;
            view.setUint32(offset, 0x02014b50, true); offset += 4;
            view.setUint16(offset, 20, true); offset += 2;
            view.setUint16(offset, 20, true); offset += 2;
            view.setUint16(offset, 0, true); offset += 2;
            view.setUint16(offset, 0, true); offset += 2;
            view.setUint16(offset, dosTime, true); offset += 2;
            view.setUint16(offset, dosDate, true); offset += 2;
            view.setUint32(offset, crc32, true); offset += 4;
            view.setUint32(offset, fileContentBytes.length, true); offset += 4;
            view.setUint32(offset, fileContentBytes.length, true); offset += 4;
            view.setUint16(offset, fileNameBytes.length, true); offset += 2;
            view.setUint16(offset, 0, true); offset += 2;
            view.setUint16(offset, 0, true); offset += 2;
            view.setUint16(offset, 0, true); offset += 2;
            view.setUint16(offset, 0, true); offset += 2;
            view.setUint32(offset, 0, true); offset += 4;
            view.setUint32(offset, 0, true); offset += 4;
            buffer.set(fileNameBytes, offset); offset += fileNameBytes.length;
            
            // ç»“æŸè®°å½•
            view.setUint32(offset, 0x06054b50, true); offset += 4;
            view.setUint16(offset, 0, true); offset += 2;
            view.setUint16(offset, 0, true); offset += 2;
            view.setUint16(offset, 1, true); offset += 2;
            view.setUint16(offset, 1, true); offset += 2;
            view.setUint32(offset, centralDirSize, true); offset += 4;
            view.setUint32(offset, centralDirStart, true); offset += 4;
            view.setUint16(offset, 0, true); offset += 2;
            
            return buffer.buffer;
        }
        
        // ç”ŸæˆZIPå†…å®¹ï¼ˆæœ€å°ZIPç»“æ„ï¼‰
        function generateZIPContent(targetSize) {
            // ZIPæ–‡ä»¶ç»“æ„ï¼šæœ¬åœ°æ–‡ä»¶å¤´ + æ–‡ä»¶æ•°æ® + ä¸­å¤®ç›®å½• + ç»“æŸè®°å½•
            const fileName = 'test.txt';
            const fileNameBytes = new TextEncoder().encode(fileName);
            const fileContent = 'This is a test file inside the ZIP archive.\n'.repeat(
                Math.max(1, Math.floor(targetSize / 50))
            );
            const fileContentBytes = new TextEncoder().encode(fileContent);
            
            // è®¡ç®—æ€»å¤§å°
            const localHeaderSize = 30 + fileNameBytes.length;
            const centralDirSize = 46 + fileNameBytes.length;
            const endRecordSize = 22;
            const totalSize = localHeaderSize + fileContentBytes.length + centralDirSize + endRecordSize;
            
            const buffer = new Uint8Array(totalSize);
            let offset = 0;
            
            // æœ¬åœ°æ–‡ä»¶å¤´
            const localHeader = new DataView(buffer.buffer);
            localHeader.setUint32(offset, 0x04034b50, true); offset += 4; // ç­¾å
            localHeader.setUint16(offset, 20, true); offset += 2; // ç‰ˆæœ¬
            localHeader.setUint16(offset, 0, true); offset += 2; // æ ‡å¿—
            localHeader.setUint16(offset, 0, true); offset += 2; // å‹ç¼©æ–¹æ³•ï¼ˆæ— å‹ç¼©ï¼‰
            localHeader.setUint16(offset, 0, true); offset += 2; // ä¿®æ”¹æ—¶é—´
            localHeader.setUint16(offset, 0, true); offset += 2; // ä¿®æ”¹æ—¥æœŸ
            localHeader.setUint32(offset, 0, true); offset += 4; // CRC-32
            localHeader.setUint32(offset, fileContentBytes.length, true); offset += 4; // å‹ç¼©å¤§å°
            localHeader.setUint32(offset, fileContentBytes.length, true); offset += 4; // æœªå‹ç¼©å¤§å°
            localHeader.setUint16(offset, fileNameBytes.length, true); offset += 2; // æ–‡ä»¶åé•¿åº¦
            localHeader.setUint16(offset, 0, true); offset += 2; // é¢å¤–å­—æ®µé•¿åº¦
            buffer.set(fileNameBytes, offset); offset += fileNameBytes.length;
            
            // æ–‡ä»¶æ•°æ®
            buffer.set(fileContentBytes, offset);
            const fileDataOffset = offset;
            offset += fileContentBytes.length;
            
            // ä¸­å¤®ç›®å½•
            const centralDirOffset = offset;
            const centralDir = new DataView(buffer.buffer, offset);
            centralDir.setUint32(0, 0x02014b50, true); offset += 4; // ç­¾å
            centralDir.setUint16(4, 20, true); offset += 2; // åˆ›å»ºç‰ˆæœ¬
            centralDir.setUint16(6, 20, true); offset += 2; // éœ€è¦ç‰ˆæœ¬
            centralDir.setUint16(8, 0, true); offset += 2; // æ ‡å¿—
            centralDir.setUint16(10, 0, true); offset += 2; // å‹ç¼©æ–¹æ³•
            centralDir.setUint16(12, 0, true); offset += 2; // ä¿®æ”¹æ—¶é—´
            centralDir.setUint16(14, 0, true); offset += 2; // ä¿®æ”¹æ—¥æœŸ
            centralDir.setUint32(16, 0, true); offset += 4; // CRC-32
            centralDir.setUint32(20, fileContentBytes.length, true); offset += 4; // å‹ç¼©å¤§å°
            centralDir.setUint32(24, fileContentBytes.length, true); offset += 4; // æœªå‹ç¼©å¤§å°
            centralDir.setUint16(28, fileNameBytes.length, true); offset += 2; // æ–‡ä»¶åé•¿åº¦
            centralDir.setUint16(30, 0, true); offset += 2; // é¢å¤–å­—æ®µé•¿åº¦
            centralDir.setUint16(32, 0, true); offset += 2; // æ–‡ä»¶æ³¨é‡Šé•¿åº¦
            centralDir.setUint16(34, 0, true); offset += 2; // ç£ç›˜å·
            centralDir.setUint16(36, 0, true); offset += 2; // å†…éƒ¨å±æ€§
            centralDir.setUint32(38, 0, true); offset += 4; // å¤–éƒ¨å±æ€§
            centralDir.setUint32(42, 0, true); offset += 4; // æœ¬åœ°å¤´åç§»
            buffer.set(fileNameBytes, offset); offset += fileNameBytes.length;
            
            // ç»“æŸè®°å½•
            const endRecord = new DataView(buffer.buffer, offset);
            endRecord.setUint32(0, 0x06054b50, true); offset += 4; // ç­¾å
            endRecord.setUint16(4, 0, true); offset += 2; // ç£ç›˜å·
            endRecord.setUint16(6, 0, true); offset += 2; // ä¸­å¤®ç›®å½•å¼€å§‹ç£ç›˜å·
            endRecord.setUint16(8, 1, true); offset += 2; // æœ¬ç£ç›˜è®°å½•æ•°
            endRecord.setUint16(10, 1, true); offset += 2; // æ€»è®°å½•æ•°
            endRecord.setUint32(12, centralDirSize, true); offset += 4; // ä¸­å¤®ç›®å½•å¤§å°
            endRecord.setUint32(16, centralDirOffset, true); offset += 4; // ä¸­å¤®ç›®å½•åç§»
            endRecord.setUint16(20, 0, true); offset += 2; // æ³¨é‡Šé•¿åº¦
            
            return buffer.buffer;
        }
        
        // ç”ŸæˆåŸºç¡€å†…å®¹
        function generateBaseContent(sizeInBytes, contentType) {
            if (contentType === 'zeros') {
                // å…¨é›¶æ•°æ®
                return '\0'.repeat(sizeInBytes);
            }
            
            let content = '';
            
            switch(contentType) {
                case 'random':
                    // éšæœºå­—ç¬¦
                    const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 \n';
                    for (let i = 0; i < sizeInBytes; i++) {
                        content += charset[Math.floor(Math.random() * charset.length)];
                    }
                    break;
                    
                case 'repeated':
                    // é‡å¤æ–‡æœ¬
                    const repeatedText = 'This is a test file generated by Test Tools. ';
                    const repeatCount = Math.ceil(sizeInBytes / repeatedText.length);
                    content = repeatedText.repeat(repeatCount).substring(0, sizeInBytes);
                    break;
                    
                case 'numbers':
                    // æ•°å­—åºåˆ—
                    let counter = 0;
                    while (content.length < sizeInBytes) {
                        const line = `${counter}\n`;
                        if (content.length + line.length <= sizeInBytes) {
                            content += line;
                        } else {
                            content += line.substring(0, sizeInBytes - content.length);
                        }
                        counter++;
                    }
                    break;
            }
            
            return content;
        }
        
        // è·å–æ–‡ä»¶å¤´éƒ¨ï¼ˆç”¨äºç»“æ„åŒ–å¤§æ–‡ä»¶ï¼‰
        function getFileHeader(format) {
            switch(format) {
                case 'json': return '{\n  "data": [\n';
                case 'xml': return '<?xml version="1.0" encoding="UTF-8"?>\n<root>\n';
                case 'html': return '<!DOCTYPE html>\n<html>\n<head><meta charset="UTF-8"><title>Test</title></head>\n<body>\n';
                default: return '';
            }
        }
        
        // è·å–æ–‡ä»¶å°¾éƒ¨ï¼ˆç”¨äºç»“æ„åŒ–å¤§æ–‡ä»¶ï¼‰
        function getFileFooter(format) {
            switch(format) {
                case 'json': return '  ]\n}';
                case 'xml': return '</root>';
                case 'html': return '</body>\n</html>';
                default: return '';
            }
        }

        // ä¸‹è½½Blob
        function downloadBlob(blob, fileName, fileExt) {
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${fileName}.${fileExt}`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        // æ˜¾ç¤ºç”Ÿæˆç»“æœ
        function showGenerationResult(actualSize, fileName, fileExt, format, contentType, generationTime, resultElement) {
            const sizeStr = formatFileSize(actualSize);
            const formatName = FILE_FORMATS[format]?.name || 'æœªçŸ¥æ ¼å¼';
            const contentTypeName = getContentTypeName(contentType);
            
            resultElement.innerHTML = `
                <strong>âœ… æ–‡ä»¶ç”ŸæˆæˆåŠŸï¼</strong><br><br>
                <strong>ğŸ“„ æ–‡ä»¶åï¼š</strong>${fileName}.${fileExt}<br>
                <strong>ğŸ“‹ æ–‡ä»¶æ ¼å¼ï¼š</strong>${formatName}<br>
                <strong>ğŸ“Š æ–‡ä»¶å¤§å°ï¼š</strong>${sizeStr}<br>
                <strong>ğŸ”¢ ç²¾ç¡®å­—èŠ‚æ•°ï¼š</strong>${actualSize.toLocaleString()} å­—èŠ‚<br>
                <strong>ğŸ“ å†…å®¹ç±»å‹ï¼š</strong>${contentTypeName}<br>
                <strong>â±ï¸ ç”Ÿæˆè€—æ—¶ï¼š</strong>${generationTime.toFixed(2)} ç§’<br>
                <strong>âš¡ ç”Ÿæˆé€Ÿåº¦ï¼š</strong>${formatFileSize(actualSize / generationTime)}/s<br><br>
                <em style="color: #28a745;">æ–‡ä»¶å·²å¼€å§‹ä¸‹è½½...</em>
            `;
            showToast('æ–‡ä»¶ç”ŸæˆæˆåŠŸï¼');
        }
        
        // æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
        function formatFileSize(bytes) {
            if (bytes < 1024) {
                return bytes.toFixed(0) + ' B';
            } else if (bytes < 1024 * 1024) {
                return (bytes / 1024).toFixed(2) + ' KB';
            } else if (bytes < 1024 * 1024 * 1024) {
                return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
            } else {
                return (bytes / (1024 * 1024 * 1024)).toFixed(2) + ' GB';
            }
        }
        
        // è·å–å†…å®¹ç±»å‹åç§°
        function getContentTypeName(contentType) {
            switch(contentType) {
                case 'random': return 'éšæœºå­—ç¬¦';
                case 'repeated': return 'é‡å¤æ–‡æœ¬';
                case 'numbers': return 'æ•°å­—åºåˆ—';
                case 'structured': return 'ç»“æ„åŒ–æ•°æ®';
                case 'zeros': return 'å…¨é›¶æ•°æ®';
                default: return 'æœªçŸ¥';
            }
        }
        
        // åŠ è½½ç¤ºä¾‹
        function loadFileGenExample() {
            document.getElementById('fileFormat').value = 'json';
            document.getElementById('fileSize').value = '1';
            document.getElementById('sizeUnit').value = 'MB';
            document.getElementById('fileName').value = 'test_data';
            document.querySelector('input[value="structured"]').checked = true;
            updateFileFormatUI();
        }

        // ========== æ­£åˆ™è¡¨è¾¾å¼æµ‹è¯•å™¨ ==========
        // æµ‹è¯•æ­£åˆ™åŒ¹é…
        function testRegex() {
            const pattern = document.getElementById('regexPattern').value;
            const text = document.getElementById('regexTestText').value;
            const result = document.getElementById('regexResult');
            const error = document.getElementById('regexError');
            
            error.textContent = '';
            document.getElementById('regexReplaceGroup').style.display = 'none';
            
            if (!pattern) {
                error.textContent = 'è¯·è¾“å…¥æ­£åˆ™è¡¨è¾¾å¼';
                return;
            }
            
            try {
                const flags = getRegexFlags();
                const regex = new RegExp(pattern, flags);
                const matches = text.match(regex);
                
                if (matches && matches.length > 0) {
                    let output = `âœ… æ‰¾åˆ° ${matches.length} ä¸ªåŒ¹é…é¡¹ï¼š\n\n`;
                    matches.forEach((match, index) => {
                        output += `[${index + 1}] ${match}\n`;
                    });
                    
                    // æ˜¾ç¤ºåŒ¹é…ä½ç½®
                    output += '\nğŸ“ åŒ¹é…ä½ç½®é«˜äº®ï¼š\n';
                    let highlightedText = text;
                    let offset = 0;
                    const globalRegex = new RegExp(pattern, flags);
                    let match;
                    const positions = [];
                    
                    while ((match = globalRegex.exec(text)) !== null) {
                        positions.push({
                            index: match.index,
                            length: match[0].length,
                            text: match[0]
                        });
                        if (!flags.includes('g')) break;
                    }
                    
                    // ä»åå¾€å‰æ›¿æ¢ï¼Œé¿å…ä½ç½®åç§»
                    for (let i = positions.length - 1; i >= 0; i--) {
                        const pos = positions[i];
                        highlightedText = 
                            highlightedText.substring(0, pos.index) + 
                            'ã€' + pos.text + 'ã€‘' + 
                            highlightedText.substring(pos.index + pos.length);
                    }
                    
                    output += highlightedText;
                    result.textContent = output;
                } else {
                    result.textContent = 'âŒ æœªæ‰¾åˆ°åŒ¹é…é¡¹';
                }
            } catch (e) {
                error.textContent = 'âŒ æ­£åˆ™è¡¨è¾¾å¼é”™è¯¯ï¼š' + e.message;
                result.textContent = 'è¯·ä¿®æ­£æ­£åˆ™è¡¨è¾¾å¼';
            }
        }
        
        // æ›¿æ¢
        function replaceWithRegex() {
            const pattern = document.getElementById('regexPattern').value;
            const text = document.getElementById('regexTestText').value;
            const replaceGroup = document.getElementById('regexReplaceGroup');
            const result = document.getElementById('regexResult');
            const error = document.getElementById('regexError');
            
            error.textContent = '';
            
            if (!pattern) {
                error.textContent = 'è¯·è¾“å…¥æ­£åˆ™è¡¨è¾¾å¼';
                return;
            }
            
            // æ˜¾ç¤ºæ›¿æ¢è¾“å…¥æ¡†
            replaceGroup.style.display = 'block';
            const replaceText = document.getElementById('regexReplaceText').value;
            
            try {
                const flags = getRegexFlags();
                const regex = new RegExp(pattern, flags);
                const replaced = text.replace(regex, replaceText);
                
                result.textContent = 'âœ… æ›¿æ¢åçš„æ–‡æœ¬ï¼š\n\n' + replaced;
            } catch (e) {
                error.textContent = 'âŒ æ­£åˆ™è¡¨è¾¾å¼é”™è¯¯ï¼š' + e.message;
                result.textContent = 'è¯·ä¿®æ­£æ­£åˆ™è¡¨è¾¾å¼';
            }
        }
        
        // æå–åŒ¹é…é¡¹
        function extractWithRegex() {
            const pattern = document.getElementById('regexPattern').value;
            const text = document.getElementById('regexTestText').value;
            const result = document.getElementById('regexResult');
            const error = document.getElementById('regexError');
            
            error.textContent = '';
            document.getElementById('regexReplaceGroup').style.display = 'none';
            
            if (!pattern) {
                error.textContent = 'è¯·è¾“å…¥æ­£åˆ™è¡¨è¾¾å¼';
                return;
            }
            
            try {
                const flags = getRegexFlags();
                const regex = new RegExp(pattern, flags);
                const matches = [];
                let match;
                
                if (flags.includes('g')) {
                    while ((match = regex.exec(text)) !== null) {
                        matches.push(match[0]);
                    }
                } else {
                    match = regex.exec(text);
                    if (match) matches.push(match[0]);
                }
                
                if (matches.length > 0) {
                    result.textContent = 'âœ… æå–çš„åŒ¹é…é¡¹ï¼ˆæ¯è¡Œä¸€ä¸ªï¼‰ï¼š\n\n' + matches.join('\n');
                } else {
                    result.textContent = 'âŒ æœªæ‰¾åˆ°åŒ¹é…é¡¹';
                }
            } catch (e) {
                error.textContent = 'âŒ æ­£åˆ™è¡¨è¾¾å¼é”™è¯¯ï¼š' + e.message;
                result.textContent = 'è¯·ä¿®æ­£æ­£åˆ™è¡¨è¾¾å¼';
            }
        }
        
        // è·å–æ­£åˆ™æ ‡å¿—
        function getRegexFlags() {
            let flags = '';
            if (document.getElementById('regexGlobal').checked) flags += 'g';
            if (document.getElementById('regexMultiline').checked) flags += 'm';
            if (document.getElementById('regexIgnoreCase').checked) flags += 'i';
            return flags;
        }
        
        // åŠ è½½ç¤ºä¾‹
        function loadRegexExample() {
            document.getElementById('regexPattern').value = '\\d{3}-\\d{4}-\\d{4}';
            document.getElementById('regexTestText').value = 'è”ç³»ç”µè¯ï¼š010-1234-5678\næ‰‹æœºå·ç ï¼š138-8888-9999\nå›ºå®šç”µè¯ï¼š021-5678-1234';
            document.getElementById('regexGlobal').checked = true;
            document.getElementById('regexMultiline').checked = false;
            document.getElementById('regexIgnoreCase').checked = false;
            document.getElementById('regexReplaceGroup').style.display = 'none';
            document.getElementById('regexResult').textContent = 'è¾“å…¥æ­£åˆ™è¡¨è¾¾å¼å’Œæµ‹è¯•æ–‡æœ¬åç‚¹å‡»æµ‹è¯•';
            document.getElementById('regexError').textContent = '';
        }
        
        // æ¸…ç©º
        function clearRegex() {
            document.getElementById('regexPattern').value = '';
            document.getElementById('regexTestText').value = '';
            document.getElementById('regexReplaceText').value = '';
            document.getElementById('regexGlobal').checked = true;
            document.getElementById('regexMultiline').checked = false;
            document.getElementById('regexIgnoreCase').checked = false;
            document.getElementById('regexReplaceGroup').style.display = 'none';
            document.getElementById('regexResult').textContent = 'è¾“å…¥æ­£åˆ™è¡¨è¾¾å¼å’Œæµ‹è¯•æ–‡æœ¬åç‚¹å‡»æµ‹è¯•';
            document.getElementById('regexError').textContent = '';
        }

        // ========== å­—ç¬¦æ•°é‡ç»Ÿè®¡ ==========
        // ç»Ÿè®¡å­—ç¬¦
        function countCharacters() {
            const text = document.getElementById('charCountText').value;
            
            // å­—ç¬¦æ€»æ•°
            const totalChars = text.length;
            
            // å­—ç¬¦æ•°ï¼ˆä¸å«ç©ºæ ¼ï¼‰
            const charsNoSpace = text.replace(/\s/g, '').length;
            
            // ä¸­æ–‡å­—ç¬¦æ•°ï¼ˆåŒ…æ‹¬ä¸­æ–‡æ ‡ç‚¹ï¼‰
            const chineseChars = (text.match(/[\u4e00-\u9fa5\u3000-\u303f\uff00-\uffef]/g) || []).length;
            
            // è‹±æ–‡å­—æ¯æ•°
            const englishChars = (text.match(/[a-zA-Z]/g) || []).length;
            
            // æ•°å­—å­—ç¬¦æ•°
            const digitChars = (text.match(/\d/g) || []).length;
            
            // æ ‡ç‚¹ç¬¦å·æ•°ï¼ˆåŒ…æ‹¬ä¸­è‹±æ–‡æ ‡ç‚¹ï¼‰
            const punctuationChars = (text.match(/[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?~`ï¼@#ï¿¥%â€¦â€¦&*ï¼ˆï¼‰â€”â€”+ã€ã€‘{}ï¼›'ï¼š""ã€ã€Šã€‹ï¼Ÿï¼Œã€‚]/g) || []).length;
            
            // ç©ºæ ¼æ•°ï¼ˆåŒ…æ‹¬åˆ¶è¡¨ç¬¦ã€æ¢è¡Œç¬¦ï¼‰
            const spaceChars = (text.match(/\s/g) || []).length;
            
            // è¡Œæ•°
            const lineCount = text.split('\n').length;
            
            // å•è¯æ•°ï¼ˆä»¥ç©ºæ ¼åˆ†éš”ï¼‰
            const words = text.trim().split(/\s+/);
            const wordCount = text.trim() === '' ? 0 : words.length;
            
            // æ®µè½æ•°ï¼ˆä»¥ç©ºè¡Œåˆ†éš”ï¼‰
            const paragraphs = text.split(/\n\s*\n/).filter(p => p.trim() !== '');
            const paragraphCount = paragraphs.length;
            
            // æ›´æ–°æ˜¾ç¤º
            document.getElementById('totalChars').textContent = totalChars;
            document.getElementById('charsNoSpace').textContent = charsNoSpace;
            document.getElementById('chineseChars').textContent = chineseChars;
            document.getElementById('englishChars').textContent = englishChars;
            document.getElementById('digitChars').textContent = digitChars;
            document.getElementById('punctuationChars').textContent = punctuationChars;
            document.getElementById('spaceChars').textContent = spaceChars;
            document.getElementById('lineCount').textContent = lineCount;
            document.getElementById('wordCount').textContent = wordCount;
            document.getElementById('paragraphCount').textContent = paragraphCount;
        }
        
        // åŠ è½½ç¤ºä¾‹
        function loadCharCountExample() {
            const exampleText = `è¿™æ˜¯ä¸€ä¸ªå­—ç¬¦ç»Ÿè®¡ç¤ºä¾‹æ–‡æœ¬ã€‚
It contains both Chinese and English characters.

è¿™ä¸ªå·¥å…·å¯ä»¥ç»Ÿè®¡ï¼š
1. æ€»å­—ç¬¦æ•°
2. ä¸­æ–‡å­—ç¬¦æ•°
3. è‹±æ–‡å­—æ¯æ•°
4. æ•°å­—ï¼š12345
5. æ ‡ç‚¹ç¬¦å·ç­‰

Try it yourself! è¯•è¯•çœ‹ï¼`;
            
            document.getElementById('charCountText').value = exampleText;
            countCharacters();
        }
        
        // æ¸…ç©º
        function clearCharCount() {
            document.getElementById('charCountText').value = '';
            countCharacters();
        }
    </script>
</body>
</html>
